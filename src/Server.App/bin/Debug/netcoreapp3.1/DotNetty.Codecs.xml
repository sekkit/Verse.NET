<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetty.Codecs</name>
    </assembly>
    <members>
        <member name="T:DotNetty.Codecs.Base64.Base64Dialect.StandardDialect">
            <summary>
            http://www.faqs.org/rfcs/rfc3548.html
            Table 1: The Base 64 Alphabet
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Base64.Base64Dialect.UrlSafeDialect">
            <summary>
            http://www.faqs.org/rfcs/rfc3548.html
            Table 2: The "URL and Filename safe" Base 64 Alphabet
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.ByteToMessageCodec`1">
             <summary>
             A Codec for on-the-fly encoding/decoding of bytes to messages and vise-versa.
            
             This can be thought of as a combination of <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> and <see cref="T:DotNetty.Codecs.MessageToByteEncoder`1"/>.
            
             Be aware that sub-classes of <see cref="T:DotNetty.Codecs.ByteToMessageCodec`1"/> <strong>MUST NOT</strong>
             annotated with <see cref="P:DotNetty.Transport.Channels.ChannelHandlerAdapter.IsSharable"/>.
             </summary>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.#ctor">
            <summary>Create a new instance which will try to detect the types to match out of the type parameter of the class.</summary>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.Write(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.HandlerRemovedInternal(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Gets called after the <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> was removed from the actual context and it doesn't handle
            events anymore.
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.AcceptOutboundMessage(System.Object)">
            <inheritdoc cref="M:DotNetty.Codecs.MessageToByteEncoder`1.AcceptOutboundMessage(System.Object)"/>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,DotNetty.Buffers.IByteBuffer)">
            <inheritdoc cref="M:DotNetty.Codecs.MessageToByteEncoder`1.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,DotNetty.Buffers.IByteBuffer)"/>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc cref="M:DotNetty.Codecs.ByteToMessageDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})"/>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageCodec`1.DecodeLast(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc cref="M:DotNetty.Codecs.ByteToMessageDecoder.DecodeLast(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})"/>
        </member>
        <member name="T:DotNetty.Codecs.ByteToMessageDecoder">
             <summary>
             <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/> which decodes bytes in a stream-like fashion from one <see cref="T:DotNetty.Buffers.IByteBuffer"/> to an
             other Message type.
            
             For example here is an implementation which reads all readable bytes from
             the input <see cref="T:DotNetty.Buffers.IByteBuffer"/> and create a new {<see cref="T:DotNetty.Buffers.IByteBuffer"/>.
            
             <![CDATA[
                 public class SquareDecoder : ByteToMessageDecoder
                 {
                     public override void Decode(IChannelHandlerContext context, IByteBuffer input, List<object> output)
                     {
                         output.add(input.ReadBytes(input.ReadableBytes));
                     }
                 }
             ]]>
            
             <c>Frame detection</c>
             <para>
             Generally frame detection should be handled earlier in the pipeline by adding a
             <see cref="T:DotNetty.Codecs.DelimiterBasedFrameDecoder"/>, <see cref="T:DotNetty.Codecs.FixedLengthFrameDecoder"/>, <see cref="T:DotNetty.Codecs.LengthFieldBasedFrameDecoder"/>,
             or <see cref="T:DotNetty.Codecs.LineBasedFrameDecoder"/>.
             </para>
             <para>
             If a custom frame decoder is required, then one needs to be careful when implementing
             one with <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/>. Ensure there are enough bytes in the buffer for a
             complete frame by checking <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes"/>. If there are not enough bytes
             for a complete frame, return without modifying the reader index to allow more bytes to arrive.
             </para>
             <para>
             To check for complete frames without modifying the reader index, use methods like <see cref="M:DotNetty.Buffers.IByteBuffer.GetInt(System.Int32)"/>.
             One <c>MUST</c> use the reader index when using methods like <see cref="M:DotNetty.Buffers.IByteBuffer.GetInt(System.Int32)"/>.
             For example calling <tt>input.GetInt(0)</tt> is assuming the frame starts at the beginning of the buffer, which
             is not always the case. Use <tt>input.GetInt(input.ReaderIndex)</tt> instead.
             <c>Pitfalls</c>
             </para>
             <para>
             Be aware that sub-classes of <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> <c>MUST NOT</c>
             annotated with <see cref="P:DotNetty.Transport.Channels.ChannelHandlerAdapter.IsSharable"/>.
             </para>
             Some methods such as <see cref="M:DotNetty.Buffers.IByteBuffer.ReadBytes(System.Int32)"/> will cause a memory leak if the returned buffer
             is not released or added to the <tt>output</tt> <see cref="T:System.Collections.Generic.List`1"/>. Use derived buffers like <see cref="M:DotNetty.Buffers.IByteBuffer.ReadSlice(System.Int32)"/>
             to avoid leaking memory.
             </summary>
        </member>
        <member name="F:DotNetty.Codecs.ByteToMessageDecoder.MergeCumulator">
            <summary>
            Cumulates instances of <see cref="T:DotNetty.Buffers.IByteBuffer" /> by merging them into one <see cref="T:DotNetty.Buffers.IByteBuffer" />, using memory copies.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.ByteToMessageDecoder.CompositionCumulation">
            <summary>
            Cumulate instances of <see cref="T:DotNetty.Buffers.IByteBuffer" /> by add them to a <see cref="T:DotNetty.Buffers.CompositeByteBuffer" /> and therefore
            avoiding memory copy when possible.
            </summary>
            <remarks>
            Be aware that <see cref="T:DotNetty.Buffers.CompositeByteBuffer" /> use a more complex indexing implementation so depending on your use-case
            and the decoder implementation this may be slower then just use the <see cref="F:DotNetty.Codecs.ByteToMessageDecoder.MergeCumulator" />.
            </remarks>
        </member>
        <member name="F:DotNetty.Codecs.ByteToMessageDecoder._firedChannelRead">
            <summary>
            This flag is used to determine if we need to call <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.Read"/> to consume more data
            when <see cref="P:DotNetty.Transport.Channels.IChannelConfiguration.AutoRead"/> is <c>false</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.ByteToMessageDecoder._decodeState">
            <summary>
            A bitmask where the bits are defined as
            <see cref="F:DotNetty.Codecs.ByteToMessageDecoder.STATE_INIT"/>
            <see cref="F:DotNetty.Codecs.ByteToMessageDecoder.STATE_CALLING_CHILD_DECODE"/>
            <see cref="F:DotNetty.Codecs.ByteToMessageDecoder.STATE_HANDLER_REMOVED_PENDING"/>
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.ByteToMessageDecoder.SingleDecode">
            <summary>
            Determines whether only one message should be decoded per <see cref="M:DotNetty.Codecs.ByteToMessageDecoder.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)" /> call.
            This may be useful if you need to do some protocol upgrade and want to make sure nothing is mixed up.
            
            Default is <c>false</c> as this has performance impacts.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.SetCumulator(DotNetty.Codecs.ByteToMessageDecoder.ICumulator)">
            <summary>
            Set the <see cref="T:DotNetty.Codecs.ByteToMessageDecoder.ICumulator"/> to use for cumulate the received <see cref="T:DotNetty.Buffers.IByteBuffer"/>s.
            </summary>
            <param name="cumulator"></param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.SetDiscardAfterReads(System.Int32)">
            <summary>
            Set the number of reads after which <see cref="M:DotNetty.Buffers.IByteBuffer.DiscardSomeReadBytes"/> are called and so free up memory.
            The default is <code>16</code>.
            </summary>
            <param name="discardAfterReads"></param>
        </member>
        <member name="P:DotNetty.Codecs.ByteToMessageDecoder.ActualReadableBytes">
            <summary>
            Returns the actual number of readable bytes in the internal cumulative
            buffer of this decoder. You usually do not need to rely on this value
            to write a decoder. Use it only when you must use it at your own risk.
            This method is a shortcut to <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes" /> of <see cref="P:DotNetty.Codecs.ByteToMessageDecoder.InternalBuffer" />.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.ByteToMessageDecoder.InternalBuffer">
            <summary>
            Returns the internal cumulative buffer of this decoder. You usually
            do not need to access the internal buffer directly to write a decoder.
            Use it only when you must use it at your own risk.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.HandlerRemovedInternal(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Gets called after the <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> was removed from the actual context and it doesn't handle
            events anymore.
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.FireChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Collections.Generic.List{System.Object},System.Int32)">
            <summary>
            Get <paramref name="numElements"/> out of the <paramref name="output"/> and forward these through the pipeline.
            </summary>
            <param name="ctx"></param>
            <param name="output"></param>
            <param name="numElements"></param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.ChannelInputClosed(DotNetty.Transport.Channels.IChannelHandlerContext,System.Collections.Generic.List{System.Object})">
            <summary>
            Called when the input of the channel was closed which may be because it changed to inactive or because of
            <see cref="T:DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent"/>
            </summary>
            <param name="ctx"></param>
            <param name="output"></param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.CallDecode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <summary>
            Called once data should be decoded from the given <see cref="T:DotNetty.Buffers.IByteBuffer"/>. This method will call
            <see cref="M:DotNetty.Codecs.ByteToMessageDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})"/> as long as decoding should take place.
            </summary>
            <param name="context"></param>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <summary>
            Decode the from one <see cref="T:DotNetty.Buffers.IByteBuffer"/> to an other. This method will be called till either the input
            <see cref="T:DotNetty.Buffers.IByteBuffer"/> has nothing to read when return from this method or till nothing was read from the input
            <see cref="T:DotNetty.Buffers.IByteBuffer"/>.
            </summary>
            <param name="context">the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> which this <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> belongs to</param>
            <param name="input">the <see cref="T:DotNetty.Buffers.IByteBuffer"/> from which to read data</param>
            <param name="output">the <see cref="T:System.Collections.Generic.List`1"/> to which decoded messages should be added</param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.DecodeRemovalReentryProtection(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <summary>
            Decode the from one <see cref="T:DotNetty.Buffers.IByteBuffer"/> to an other. This method will be called till either the input
            <see cref="T:DotNetty.Buffers.IByteBuffer"/> has nothing to read when return from this method or till nothing was read from the input
            <see cref="T:DotNetty.Buffers.IByteBuffer"/>.
            </summary>
            <param name="ctx">the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> which this <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> belongs to</param>
            <param name="input">the <see cref="T:DotNetty.Buffers.IByteBuffer"/> from which to read data</param>
            <param name="output">the <see cref="T:System.Collections.Generic.List`1"/> to which decoded messages should be added</param>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.DecodeLast(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <summary>
            Is called one last time when the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> goes in-active. Which means the
            <see cref="M:DotNetty.Codecs.ByteToMessageDecoder.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)"/> was triggered.
            
            By default this will just call <see cref="M:DotNetty.Codecs.ByteToMessageDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})"/> but sub-classes may
            override this for some special cleanup operation.
            </summary>
            <param name="context"></param>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:DotNetty.Codecs.ByteToMessageDecoder.ICumulator">
            <summary>
            Cumulate <see cref="T:DotNetty.Buffers.IByteBuffer"/>s.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ByteToMessageDecoder.ICumulator.Cumulate(DotNetty.Buffers.IByteBufferAllocator,DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Cumulate the given <see cref="T:DotNetty.Buffers.IByteBuffer"/>s and return the <see cref="T:DotNetty.Buffers.IByteBuffer"/> that holds the cumulated bytes.
            The implementation is responsible to correctly handle the life-cycle of the given <see cref="T:DotNetty.Buffers.IByteBuffer"/>s and so
            call <see cref="M:DotNetty.Common.IReferenceCounted.Release"/> if a <see cref="T:DotNetty.Buffers.IByteBuffer"/> is fully consumed.
            </summary>
            <param name="alloc"></param>
            <param name="cumulation"></param>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Codecs.CodecException">
            <summary>
                An <see cref="T:System.Exception" /> which is thrown by a codec.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.Adler32">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/Adler32.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.CRC32">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/CRC32.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.Deflate">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/Deflate.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.Deflater">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/Deflater.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.GZIPException">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/GZIPException.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.GZIPHeader">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/GZIPHeader.java
            
            http://www.ietf.org/rfc/rfc1952.txt
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.InfBlocks">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/InfBlocks.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.InfCodes">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/InfCodes.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.Inflate">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/Inflate.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.Inflater">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/Inflater.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.InfTree">
            <summary>
             https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/InfTree.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.JZlib">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/JZlib.java
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Compression.JZlibDecoder.#ctor">
            <summary>
            Creates a new instance with the default wrapper (<see cref="F:DotNetty.Codecs.Compression.ZlibWrapper.ZlibOrNone"/>).
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Compression.JZlibDecoder.#ctor(System.Int32)">
            <summary>
            Creates a new instance with the default wrapper (<see cref="F:DotNetty.Codecs.Compression.ZlibWrapper.ZlibOrNone"/>)
            and specified maximum buffer allocation.
            </summary>
            <param name="maxAllocation">Maximum size of the decompression buffer. Must be &gt;= 0.
            If zero, maximum size is decided by the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>.</param>
        </member>
        <member name="M:DotNetty.Codecs.Compression.JZlibDecoder.#ctor(DotNetty.Codecs.Compression.ZlibWrapper)">
            <summary>
            Creates a new instance with the specified wrapper.
            </summary>
            <param name="wrapper"></param>
        </member>
        <member name="M:DotNetty.Codecs.Compression.JZlibDecoder.#ctor(DotNetty.Codecs.Compression.ZlibWrapper,System.Int32)">
            <summary>
            Creates a new instance with the specified wrapper and maximum buffer allocation.
            </summary>
            <param name="wrapper"></param>
            <param name="maxAllocation">Maximum size of the decompression buffer. Must be &gt;= 0.
            If zero, maximum size is decided by the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>.</param>
        </member>
        <member name="M:DotNetty.Codecs.Compression.JZlibDecoder.#ctor(System.Byte[])">
            <summary>
            Creates a new instance with the specified preset dictionary. The wrapper
            is always <see cref="F:DotNetty.Codecs.Compression.ZlibWrapper.Zlib"/> because it is the only format that
            supports the preset dictionary.
            </summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:DotNetty.Codecs.Compression.JZlibDecoder.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a new instance with the specified preset dictionary and maximum buffer allocation.
            The wrapper is always <see cref="F:DotNetty.Codecs.Compression.ZlibWrapper.Zlib"/> because it is the only format that
            supports the preset dictionary.
            </summary>
            <param name="dictionary"></param>
            <param name="maxAllocation">Maximum size of the decompression buffer. Must be &gt;= 0.
            If zero, maximum size is decided by the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>.</param>
        </member>
        <member name="M:DotNetty.Codecs.Compression.JZlibEncoder.#ctor(DotNetty.Codecs.Compression.ZlibWrapper,System.Int32,System.Int32,System.Int32)">
             Creates a new zlib encoder with the specified {@code compressionLevel},
             the specified {@code windowBits}, the specified {@code memLevel}, and
             the specified wrapper.
            
             @param compressionLevel
                    {@code 1} yields the fastest compression and {@code 9} yields the
                    best compression.  {@code 0} means no compression.  The default
                    compression level is {@code 6}.
             @param windowBits
                    The base two logarithm of the size of the history buffer.  The
                    value should be in the range {@code 9} to {@code 15} inclusive.
                    Larger values result in better compression at the expense of
                    memory usage.  The default value is {@code 15}.
             @param memLevel
                    How much memory should be allocated for the internal compression
                    state.  {@code 1} uses minimum memory and {@code 9} uses maximum
                    memory.  Larger values result in better and faster compression
                    at the expense of memory usage.  The default value is {@code 8}
            
             @throws CompressionException if failed to initialize zlib
        </member>
        <member name="T:DotNetty.Codecs.Compression.StaticTree">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/StaticTree.java
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Compression.Tree">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/Tree.java
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Compression.ZlibDecoder._maxAllocation">
            <summary>
            Maximum allowed size of the decompression buffer.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Compression.ZlibDecoder.#ctor">
            <summary>Construct a new ZlibDecoder.</summary>
        </member>
        <member name="M:DotNetty.Codecs.Compression.ZlibDecoder.#ctor(System.Int32)">
            <summary>Construct a new ZlibDecoder.</summary>
            <param name="maxAllocation">Maximum size of the decompression buffer. Must be &gt;= 0.
            If zero, maximum size is decided by the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/>.</param>
        </member>
        <member name="M:DotNetty.Codecs.Compression.ZlibDecoder.PrepareDecompressBuffer(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
            Allocate or expand the decompression buffer, without exceeding the maximum allocation.
            Calls <see cref="M:DotNetty.Codecs.Compression.ZlibDecoder.DecompressionBufferExhausted(DotNetty.Buffers.IByteBuffer)"/> if the buffer is full and cannot be expanded further.
            </summary>
            <param name="ctx"></param>
            <param name="buffer"></param>
            <param name="preferredSize"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Compression.ZlibDecoder.DecompressionBufferExhausted(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Called when the decompression buffer cannot be expanded further.
            Default implementation is a no-op, but subclasses can override in case they want to
            do something before the <see cref="T:DotNetty.Codecs.Compression.DecompressionException"/> is thrown, such as log the
            data that was decompressed so far.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:DotNetty.Codecs.Compression.ZlibEncoder.CloseAsync">
             Close this {@link ZlibEncoder} and so finish the encoding.
            
             The returned {@link ChannelFuture} will be notified once the
             operation completes.
        </member>
        <member name="T:DotNetty.Codecs.Compression.ZlibWrapper">
            The container file formats that wrap the stream compressed by the DEFLATE
            algorithm.
        </member>
        <member name="F:DotNetty.Codecs.Compression.ZlibWrapper.Zlib">
            The ZLIB wrapper as specified in <a href="http://tools.ietf.org/html/rfc1950">RFC 1950</a>.
        </member>
        <member name="F:DotNetty.Codecs.Compression.ZlibWrapper.Gzip">
            The GZIP wrapper as specified in <a href="http://tools.ietf.org/html/rfc1952">RFC 1952</a>.
        </member>
        <member name="F:DotNetty.Codecs.Compression.ZlibWrapper.None">
            Raw DEFLATE stream only (no header and no footer).
        </member>
        <member name="F:DotNetty.Codecs.Compression.ZlibWrapper.ZlibOrNone">
            Try {@link #ZLIB} first and then {@link #NONE} if the first attempt fails.
            Please note that you can specify this wrapper type only when decompressing.
        </member>
        <member name="T:DotNetty.Codecs.Compression.ZStream">
            <summary>
            https://github.com/ymnk/jzlib/blob/master/src/main/java/com/jcraft/jzlib/ZStream.java
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Compression.ZStream.End">
            Those methods are expected to be override by Inflater and Deflater.
            In the future, they will become abstract methods.
        </member>
        <member name="T:DotNetty.Codecs.CorruptedFrameException">
            <summary>
                A <see cref="T:DotNetty.Codecs.DecoderException" /> which is thrown when the received frame data could not
                be decoded by an inbound handler.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.DatagramPacketDecoder">
            <summary>
            A decoder that decodes the content of the received <see cref="T:DotNetty.Transport.Channels.Sockets.DatagramPacket"/> using
            the specified <see cref="T:DotNetty.Buffers.IByteBuffer"/> decoder. E.g.,
            <code>
            <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> pipeline = ...;
            pipeline.AddLast("udpDecoder", new <see cref="T:DotNetty.Codecs.DatagramPacketDecoder"/>(new <see cref="T:ProtobufDecoder"/>(...));
            </code>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.#ctor(DotNetty.Codecs.MessageToMessageDecoder{DotNetty.Buffers.IByteBuffer})">
            <summary>
            Create a <see cref="T:DotNetty.Transport.Channels.Sockets.DatagramPacket"/> decoder using the specified <see cref="T:DotNetty.Buffers.IByteBuffer"/> decoder.
            </summary>
            <param name="decoder">the specified <see cref="T:DotNetty.Buffers.IByteBuffer"/> decoder</param>
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.AcceptInboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Transport.Channels.Sockets.DatagramPacket,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.ChannelRegistered(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.ChannelUnregistered(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.ChannelActive(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.ChannelWritabilityChanged(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketDecoder.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.DatagramPacketEncoder`1">
             <summary>
             An encoder that encodes the content in <see cref="T:DotNetty.Transport.Channels.IAddressedEnvelope`1"/> to <see cref="T:DotNetty.Transport.Channels.Sockets.DatagramPacket"/> using
             the specified message encoder. E.g.,
            
             <code>
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> pipeline = ...;
             pipeline.addLast("udpEncoder", new <see cref="T:DotNetty.Codecs.DatagramPacketEncoder`1"/>(new <see cref="T:ProtobufEncoder"/>(...));
             </code>
            
             Note: As UDP packets are out-of-order, you should make sure the encoded message size are not greater than
             the max safe packet size in your particular network path which guarantees no packet fragmentation.
             </summary>
             <typeparam name="T">the type of message to be encoded</typeparam>
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.#ctor(DotNetty.Codecs.MessageToMessageEncoder{`0})">
            <summary>
            Create an encoder that encodes the content in <see cref="T:DotNetty.Transport.Channels.IAddressedEnvelope`1"/> to <see cref="T:DotNetty.Transport.Channels.Sockets.DatagramPacket"/> using
            the specified message encoder.
            </summary>
            <param name="encoder">the specified message encoder</param>
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Transport.Channels.IAddressedEnvelope{`0},System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.BindAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.Disconnect(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.Close(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.Deregister(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.Read(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.Flush(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DatagramPacketEncoder`1.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.DateFormatter">
             <summary>
             A formatter for HTTP header dates, such as "Expires" and "Date" headers, or "expires" field in "Set-Cookie".
            
             On the parsing side, it honors RFC6265 (so it supports RFC1123).
             Note that:
             <ul>
                 <li>Day of week is ignored and not validated</li>
                 <li>Timezone is ignored, as RFC6265 assumes UTC</li>
             </ul>
             If you're looking for a date format that validates day of week, or supports other timezones, consider using
             java.util.DateTimeFormatter.RFC_1123_DATE_TIME.
            
             On the formatting side, it uses a subset of RFC1123 (2 digit day-of-month and 4 digit year) as per RFC2616.
             This subset supports RFC6265.
            
             @see <a href="https://tools.ietf.org/html/rfc6265#section-5.1.1">RFC6265</a> for the parsing side
             @see <a href="https://tools.ietf.org/html/rfc1123#page-55">RFC1123</a> and
             <a href="https://tools.ietf.org/html/rfc2616#section-3.3.1">RFC2616</a> for the encoding side.
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.DelimiterBasedFrameDecoder">
            <summary>
                A decoder that splits the received <see cref="T:DotNetty.Buffers.IByteBuffer" /> by one or more
                delimiters.It is particularly useful for decoding the frames which ends
                with a delimiter such as <see cref="M:DotNetty.Codecs.Delimiters.NullDelimiter" /> or
                <see cref="M:DotNetty.Codecs.Delimiters.LineDelimiter" />
                <h3>Specifying more than one delimiter </h3>
                <see cref="M:DotNetty.Codecs.Delimiters.NullDelimiter" /> allows you to specify more than one
                delimiter.  If more than one delimiter is found in the buffer, it chooses
                the delimiter which produces the shortest frame.  For example, if you have
                the following data in the buffer:
                +--------------+
                | ABC\nDEF\r\n |
                +--------------+
                a <see cref="M:DotNetty.Codecs.Delimiters.LineDelimiter" /> will choose '\n' as the first delimiter and produce two
                frames:
                +-----+-----+
                | ABC | DEF |
                +-----+-----+
                rather than incorrectly choosing '\r\n' as the first delimiter:
                +----------+
                | ABC\nDEF |
                +----------+
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.#ctor(System.Int32,System.Boolean,System.Boolean,DotNetty.Buffers.IByteBuffer[])">
            <summary>Common constructor</summary>
            <param name="maxFrameLength">
                The maximum length of the decoded frame
                NOTE: A see <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is thrown if the length of the frame exceeds this
                value.
            </param>
            <param name="stripDelimiter">whether the decoded frame should strip out the delimiter or not</param>
            <param name="failFast">
                If true, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is
                thrown as soon as the decoder notices the length of the
                frame will exceed<tt>maxFrameLength</tt> regardless of
                whether the entire frame has been read.
                If false, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is
                thrown after the entire frame that exceeds maxFrameLength has been read.
            </param>
            <param name="delimiters">delimiters</param>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.#ctor(System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>Creates a new instance.</summary>
            <param name="maxFrameLength">the maximum length of the decoded frame.
            A <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is thrown if
            the length of the frame exceeds this value.</param>
            <param name="delimiter">the delimiter</param>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.#ctor(System.Int32,System.Boolean,DotNetty.Buffers.IByteBuffer)">
            <summary>Creates a new instance.</summary>
            <param name="maxFrameLength">the maximum length of the decoded frame.
            A <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is thrown if
            the length of the frame exceeds this value.</param>
            <param name="stripDelimiter">whether the decoded frame should strip out the
            delimiter or not</param>
            <param name="delimiter">the delimiter</param>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.#ctor(System.Int32,System.Boolean,System.Boolean,DotNetty.Buffers.IByteBuffer)">
            <summary>Creates a new instance.</summary>
            <param name="maxFrameLength">the maximum length of the decoded frame.
            A <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is thrown if
            the length of the frame exceeds this value.</param>
            <param name="stripDelimiter">whether the decoded frame should strip out the
            delimiter or not</param>
            <param name="failFast">If <c>true</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is
            thrown as soon as the decoder notices the length of the
            frame will exceed <paramref name="maxFrameLength"/> regardless of
            whether the entire frame has been read.
            If <c>false</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is
            thrown after the entire frame that exceeds
            <paramref name="maxFrameLength"/> has been read.</param>
            <param name="delimiter">the delimiter</param>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.#ctor(System.Int32,DotNetty.Buffers.IByteBuffer[])">
            <summary>Creates a new instance.</summary>
            <param name="maxFrameLength">the maximum length of the decoded frame.
            A <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is thrown if
            the length of the frame exceeds this value.</param>
            <param name="delimiters">the delimiters</param>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.#ctor(System.Int32,System.Boolean,DotNetty.Buffers.IByteBuffer[])">
            <summary>Creates a new instance.</summary>
            <param name="maxFrameLength">the maximum length of the decoded frame.
            A <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is thrown if
            the length of the frame exceeds this value.</param>
            <param name="stripDelimiter">whether the decoded frame should strip out the
            delimiter or not</param>
            <param name="delimiters">the delimiters</param>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.IsLineBased(DotNetty.Buffers.IByteBuffer[])">
            <summary>Returns <c>true</c> if the delimiters are "\n" and "\r\n"</summary>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.IsSubclass">
            <summary>Returns <c>true</c> if the current instance is a subclass of DelimiterBasedFrameDecoder</summary>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer)">
            <summary>Create a frame out of the <see cref="T:DotNetty.Buffers.IByteBuffer" /> and return it</summary>
            <param name="ctx">
                the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext" /> which this
                <see cref="T:DotNetty.Codecs.ByteToMessageDecoder" /> belongs to
            </param>
            <param name="buffer">the <see cref="T:DotNetty.Buffers.IByteBuffer" /> from which to read data</param>
            <returns>
                the <see cref="T:DotNetty.Buffers.IByteBuffer" /> which represent the frame or null if no frame could be
                created.
            </returns>
        </member>
        <member name="M:DotNetty.Codecs.DelimiterBasedFrameDecoder.IndexOf(DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Returns the number of bytes between the readerIndex of the haystack and
            the first needle found in the haystack.  <c>-1</c> is returned if no needle is
            found in the haystack.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Delimiters.NullDelimiter">
            <summary>Returns a null (0x00) delimiter, which could be used for Flash XML socket or any similar protocols</summary>
        </member>
        <member name="M:DotNetty.Codecs.Delimiters.LineDelimiter">
            <summary>
                Returns {@code CR ('\r')} and {@code LF ('\n')} delimiters, which could
                be used for text-based line protocols.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.FixedLengthFrameDecoder">
            A decoder that splits the received {@link ByteBuf}s by the fixed number
            of bytes. For example, if you received the following four fragmented packets:
            <pre>
            +---+----+------+----+
            | A | BC | DEFG | HI |
            +---+----+------+----+
            </pre>
            A {@link FixedLengthFrameDecoder}{@code (3)} will decode them into the
            following three packets with the fixed length:
            <pre>
            +-----+-----+-----+
            | ABC | DEF | GHI |
            +-----+-----+-----+
            </pre>
        </member>
        <member name="M:DotNetty.Codecs.FixedLengthFrameDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer)">
            <summary>Create a frame out of the <see cref="T:DotNetty.Buffers.IByteBuffer"/> and return it.</summary>
            <param name="ctx">the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> which this <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> belongs to</param>
            <param name="input">the <see cref="T:DotNetty.Buffers.IByteBuffer"/> from which to read data</param>
            <returns>the <see cref="T:DotNetty.Buffers.IByteBuffer"/> which represent the frame or <c>null</c> if no frame could be created.</returns>
        </member>
        <member name="T:DotNetty.Codecs.HeadersUtils">
            <summary>
            Provides utility methods related to <see cref="T:DotNetty.Codecs.IHeaders`2"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.HeadersUtils.GetAllAsString``2(DotNetty.Codecs.IHeaders{``0,``1},``0)">
            <summary>
            <see cref="M:DotNetty.Codecs.IHeaders`2.GetAll(`0)"/> and convert each element of <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:System.String"/>.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="headers">the headers to get the <paramref name="name"/> from</param>
            <param name="name">the name of the header to retrieve</param>
            <returns>a <see cref="T:System.Collections.Generic.List`1"/> of header values or an empty <see cref="T:System.Collections.Generic.List`1"/> if no values are found.</returns>
        </member>
        <member name="M:DotNetty.Codecs.HeadersUtils.TryGetAsString``2(DotNetty.Codecs.IHeaders{``0,``1},``0,System.String@)">
            <summary>
            <see cref="M:DotNetty.Codecs.IHeaders`2.Get(`0,`1)"/> and convert the result to a <see cref="T:System.String"/>.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="headers">the headers to get the <paramref name="name"/> from</param>
            <param name="name">the name of the header to retrieve</param>
            <param name="value">the first header value if the header is found. <c>null</c> if there's no such entry.</param>
        </member>
        <member name="M:DotNetty.Codecs.HeadersUtils.ToString``2(System.Collections.Generic.IEnumerable{DotNetty.Codecs.HeaderEntry{``0,``1}},System.Int32)">
            <summary>
            Helper for implementing toString for <see cref="T:DotNetty.Codecs.DefaultHeaders`2"/> and wrappers such as DefaultHttpHeaders.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="headers">the headers</param>
            <param name="size">the size of the headers</param>
            <returns>a String representation of the headers</returns>
        </member>
        <member name="M:DotNetty.Codecs.HeadersUtils.NamesAsString(DotNetty.Codecs.IHeaders{DotNetty.Common.Utilities.ICharSequence,DotNetty.Common.Utilities.ICharSequence})">
            <summary>
            <see cref="M:DotNetty.Codecs.IHeaders`2.Names"/> and convert each element of <see cref="T:System.Collections.Generic.ISet`1"/> to a <see cref="T:System.String"/>.
            </summary>
            <param name="headers">the headers to get the names from</param>
            <returns>a <see cref="T:System.Collections.Generic.IList`1"/> of header values or an empty <see cref="T:System.Collections.Generic.IList`1"/> if no values are found.</returns>
        </member>
        <member name="T:DotNetty.Codecs.Internal.Strings">
            <summary>
              
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Internal.Strings.ResourceManager">
            <summary>
               ResourceManager 
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Internal.Strings.Culture">
            <summary>
              
               CurrentUICulture 
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.CExceptionArgument">
            <summary>The convention for this enum is using the argument name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Codecs.CExceptionResource">
            <summary>The convention for this enum is using the resource name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Codecs.Json.JsonObjectDecoder">
            <summary>
                Splits a byte stream of JSON objects and arrays into individual objects/arrays and passes them up the
                <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />.
                <para>
                The byte stream is expected to be in UTF-8 character encoding or ASCII. The current implementation
                uses direct {@code byte} to {@code char} cast and then compares that {@code char} to a few low range
                ASCII characters like {@code '{'}, {@code '['} or {@code '"'}. UTF-8 is not using low range [0..0x7F]
                byte values for multibyte codepoint representations therefore fully supported by this implementation.
                </para>
                This class does not do any real parsing or validation. A sequence of bytes is considered a JSON object/array
                if it contains a matching number of opening and closing braces/brackets. It's up to a subsequent
                <see cref="T:DotNetty.Transport.Channels.IChannelHandler" />
                to parse the JSON text into a more usable form i.e.a POCO.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.LengthFieldBasedFrameDecoder">
             <summary>
             A decoder that splits the received <see cref="T:DotNetty.Buffers.IByteBuffer"/>s dynamically by the
             value of the length field in the message.  It is particularly useful when you
             decode a binary message which has an integer header field that represents the
             length of the message body or the whole message.
             <para>
             <see cref="T:DotNetty.Codecs.LengthFieldBasedFrameDecoder"/> has many configuration parameters so
             that it can decode any message with a length field, which is often seen in
             proprietary client-server protocols. Here are some example that will give
             you the basic idea on which option does what.
             </para>
            
             <h3>2 bytes length field at offset 0, do not strip header</h3>
            
             The value of the length field in this example is <tt>12 (0x0C)</tt> which
             represents the length of "HELLO, WORLD".  By default, the decoder assumes
             that the length field represents the number of the bytes that follows the
             length field.  Therefore, it can be decoded with the simplistic parameter
             combination.
             <code>
             <b>lengthFieldOffset</b>   = <b>0</b>
             <b>lengthFieldLength</b>   = <b>2</b>
             lengthAdjustment    = 0
             initialBytesToStrip = 0 (= do not strip header)
            
             BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
             +--------+----------------+      +--------+----------------+
             | Length | Actual Content |----->| Length | Actual Content |
             | 0x000C | "HELLO, WORLD" |      | 0x000C | "HELLO, WORLD" |
             +--------+----------------+      +--------+----------------+
             </code>
            
             <h3>2 bytes length field at offset 0, strip header</h3>
            
             Because we can get the length of the content by calling
             <see cref="P:DotNetty.Buffers.IByteBuffer.ReadableBytes"/>, you might want to strip the length
             field by specifying <tt>initialBytesToStrip</tt>.  In this example, we
             specified <tt>2</tt>, that is same with the length of the length field, to
             strip the first two bytes.
             <code>
             lengthFieldOffset   = 0
             lengthFieldLength   = 2
             lengthAdjustment    = 0
             <b>initialBytesToStrip</b> = <b>2</b> (= the length of the Length field)
            
             BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)
             +--------+----------------+      +----------------+
             | Length | Actual Content |----->| Actual Content |
             | 0x000C | "HELLO, WORLD" |      | "HELLO, WORLD" |
             +--------+----------------+      +----------------+
             </code>
            
             <h3>2 bytes length field at offset 0, do not strip header, the length field
                 represents the length of the whole message</h3>
            
             In most cases, the length field represents the length of the message body
             only, as shown in the previous examples.  However, in some protocols, the
             length field represents the length of the whole message, including the
             message header.  In such a case, we specify a non-zero
             <tt>lengthAdjustment</tt>.  Because the length value in this example message
             is always greater than the body length by <tt>2</tt>, we specify <tt>-2</tt>
             as <tt>lengthAdjustment</tt> for compensation.
             <code>
             lengthFieldOffset   =  0
             lengthFieldLength   =  2
             <b>lengthAdjustment</b>    = <b>-2</b> (= the length of the Length field)
             initialBytesToStrip =  0
            
             BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
             +--------+----------------+      +--------+----------------+
             | Length | Actual Content |----->| Length | Actual Content |
             | 0x000E | "HELLO, WORLD" |      | 0x000E | "HELLO, WORLD" |
             +--------+----------------+      +--------+----------------+
             </code>
            
             <h3>3 bytes length field at the end of 5 bytes header, do not strip header</h3>
            
             The following message is a simple variation of the first example.  An extra
             header value is prepended to the message.  <tt>lengthAdjustment</tt> is zero
             again because the decoder always takes the length of the prepended data into
             account during frame length calculation.
             <code>
             <b>lengthFieldOffset</b>   = <b>2</b> (= the length of Header 1)
             <b>lengthFieldLength</b>   = <b>3</b>
             lengthAdjustment    = 0
             initialBytesToStrip = 0
            
             BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
             +----------+----------+----------------+      +----------+----------+----------------+
             | Header 1 |  Length  | Actual Content |----->| Header 1 |  Length  | Actual Content |
             |  0xCAFE  | 0x00000C | "HELLO, WORLD" |      |  0xCAFE  | 0x00000C | "HELLO, WORLD" |
             +----------+----------+----------------+      +----------+----------+----------------+
             </code>
            
             <h3>3 bytes length field at the beginning of 5 bytes header, do not strip header</h3>
            
             This is an advanced example that shows the case where there is an extra
             header between the length field and the message body.  You have to specify a
             positive <tt>lengthAdjustment</tt> so that the decoder counts the extra
             header into the frame length calculation.
             <code>
             lengthFieldOffset   = 0
             lengthFieldLength   = 3
             <b>lengthAdjustment</b>    = <b>2</b> (= the length of Header 1)
             initialBytesToStrip = 0
            
             BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
             +----------+----------+----------------+      +----------+----------+----------------+
             |  Length  | Header 1 | Actual Content |----->|  Length  | Header 1 | Actual Content |
             | 0x00000C |  0xCAFE  | "HELLO, WORLD" |      | 0x00000C |  0xCAFE  | "HELLO, WORLD" |
             +----------+----------+----------------+      +----------+----------+----------------+
             </code>
            
             <h3>2 bytes length field at offset 1 in the middle of 4 bytes header,
                 strip the first header field and the length field</h3>
            
             This is a combination of all the examples above.  There are the prepended
             header before the length field and the extra header after the length field.
             The prepended header affects the <tt>lengthFieldOffset</tt> and the extra
             header affects the <tt>lengthAdjustment</tt>.  We also specified a non-zero
             <tt>initialBytesToStrip</tt> to strip the length field and the prepended
             header from the frame.  If you don't want to strip the prepended header, you
             could specify <tt>0</tt> for <tt>initialBytesToSkip</tt>.
             <code>
             lengthFieldOffset   = 1 (= the length of HDR1)
             lengthFieldLength   = 2
             <b>lengthAdjustment</b>    = <b>1</b> (= the length of HDR2)
             <b>initialBytesToStrip</b> = <b>3</b> (= the length of HDR1 + LEN)
            
             BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
             +------+--------+------+----------------+      +------+----------------+
             | HDR1 | Length | HDR2 | Actual Content |----->| HDR2 | Actual Content |
             | 0xCA | 0x000C | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
             +------+--------+------+----------------+      +------+----------------+
             </code>
            
             <h3>2 bytes length field at offset 1 in the middle of 4 bytes header,
                 strip the first header field and the length field, the length field
                 represents the length of the whole message</h3>
            
             Let's give another twist to the previous example.  The only difference from
             the previous example is that the length field represents the length of the
             whole message instead of the message body, just like the third example.
             We have to count the length of HDR1 and Length into <tt>lengthAdjustment</tt>.
             Please note that we don't need to take the length of HDR2 into account
             because the length field already includes the whole header length.
             <code>
             lengthFieldOffset   =  1
             lengthFieldLength   =  2
             <b>lengthAdjustment</b>    = <b>-3</b> (= the length of HDR1 + LEN, negative)
             <b>initialBytesToStrip</b> = <b> 3</b>
            
             BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
             +------+--------+------+----------------+      +------+----------------+
             | HDR1 | Length | HDR2 | Actual Content |----->| HDR2 | Actual Content |
             | 0xCA | 0x0010 | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
             +------+--------+------+----------------+      +------+----------------+
             </code>
             <see cref="T:DotNetty.Codecs.LengthFieldPrepender"/>
             </summary>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                Create a new instance.
            </summary>
            <param name="maxFrameLength">
                The maximum length of the frame.  If the length of the frame is
                greater than this value then <see cref="T:DotNetty.Codecs.TooLongFrameException" /> will be thrown.
            </param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Create a new instance.
            </summary>
            <param name="maxFrameLength">
                The maximum length of the frame.  If the length of the frame is
                greater than this value then <see cref="T:DotNetty.Codecs.TooLongFrameException" /> will be thrown.
            </param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
                Create a new instance.
            </summary>
            <param name="maxFrameLength">
                The maximum length of the frame.  If the length of the frame is
                greater than this value then <see cref="T:DotNetty.Codecs.TooLongFrameException" /> will be thrown.
            </param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
            <param name="failFast">
                If <c>true</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is thrown as soon as the decoder notices the length
                of the frame will exceeed <see cref="F:DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength" /> regardless of whether the entire frame has been
                read. If <c>false</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is thrown after the entire frame that exceeds
                <see cref="F:DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength" /> has been read.
                Defaults to <c>true</c> in other overloads.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(DotNetty.Buffers.ByteOrder,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
                Create a new instance.
            </summary>
            <param name="byteOrder">The <see cref="T:DotNetty.Buffers.ByteOrder" /> of the lenght field.</param>
            <param name="maxFrameLength">
                The maximum length of the frame.  If the length of the frame is
                greater than this value then <see cref="T:DotNetty.Codecs.TooLongFrameException" /> will be thrown.
            </param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
            <param name="failFast">
                If <c>true</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is thrown as soon as the decoder notices the length
                of the frame will exceeed <see cref="F:DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength" /> regardless of whether the entire frame has been
                read. If <c>false</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is thrown after the entire frame that exceeds
                <see cref="F:DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength" /> has been read.
                Defaults to <c>true</c> in other overloads.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Create a frame out of the <see cref="T:DotNetty.Buffers.IByteBuffer" /> and return it.
            </summary>
            <param name="context">
                The <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext" /> which this <see cref="T:DotNetty.Codecs.ByteToMessageDecoder" /> belongs
                to.
            </param>
            <param name="input">The <see cref="T:DotNetty.Buffers.IByteBuffer" /> from which to read data.</param>
            <returns>The <see cref="T:DotNetty.Buffers.IByteBuffer" /> which represents the frame or <c>null</c> if no frame could be created.</returns>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.GetUnadjustedFrameLength(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32,DotNetty.Buffers.ByteOrder)">
            <summary>
                Decodes the specified region of the buffer into an unadjusted frame length.  The default implementation is
                capable of decoding the specified region into an unsigned 8/16/24/32/64 bit integer.  Override this method to
                decode the length field encoded differently.
                Note that this method must not modify the state of the specified buffer (e.g.
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />,
                <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />, and the content of the buffer.)
            </summary>
            <param name="buffer">The buffer we'll be extracting the frame length from.</param>
            <param name="offset">The offset from the absolute <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />.</param>
            <param name="length">The length of the framelenght field. Expected: 1, 2, 3, 4, or 8.</param>
            <param name="order">The preferred <see cref="T:DotNetty.Buffers.ByteOrder" /> of buffer.</param>
            <returns>A long integer that represents the unadjusted length of the next frame.</returns>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder.ExtractFrame(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
            Extract the sub-region of the specified buffer.
            </summary>
            <param name="context"></param>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                Create a new instance.
            </summary>
            <param name="maxFrameLength">
                The maximum length of the frame.  If the length of the frame is
                greater than this value then <see cref="T:DotNetty.Codecs.TooLongFrameException" /> will be thrown.
            </param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Create a new instance.
            </summary>
            <param name="maxFrameLength">
                The maximum length of the frame.  If the length of the frame is
                greater than this value then <see cref="T:DotNetty.Codecs.TooLongFrameException" /> will be thrown.
            </param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
                Create a new instance.
            </summary>
            <param name="maxFrameLength">
                The maximum length of the frame.  If the length of the frame is
                greater than this value then <see cref="T:DotNetty.Codecs.TooLongFrameException" /> will be thrown.
            </param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
            <param name="failFast">
                If <c>true</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is thrown as soon as the decoder notices the length
                of the frame will exceeed <see cref="F:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.maxFrameLength" /> regardless of whether the entire frame has been
                read. If <c>false</c>, a <see cref="T:DotNetty.Codecs.TooLongFrameException" /> is thrown after the entire frame that exceeds
                <see cref="F:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.maxFrameLength" /> has been read.
                Defaults to <c>true</c> in other overloads.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.GetUnadjustedFrameLength(DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
                Decodes the specified region of the buffer into an unadjusted frame length.  The default implementation is
                capable of decoding the specified region into an unsigned 8/16/24/32/64 bit integer.  Override this method to
                decode the length field encoded differently.
                Note that this method must not modify the state of the specified buffer (e.g.
                <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />,
                <see cref="P:DotNetty.Buffers.IByteBuffer.WriterIndex" />, and the content of the buffer.)
            </summary>
            <param name="buffer">The buffer we'll be extracting the frame length from.</param>
            <param name="offset">The offset from the absolute <see cref="P:DotNetty.Buffers.IByteBuffer.ReaderIndex" />.</param>
            <param name="length">The length of the framelenght field. Expected: 1, 2, 3, 4, or 8.</param>
            <returns>A long integer that represents the unadjusted length of the next frame.</returns>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldBasedFrameDecoder2.ExtractFrame(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
            Extract the sub-region of the specified buffer.
            </summary>
            <param name="context"></param>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Codecs.LengthFieldPrepender">
            <summary>
                An encoder that prepends the length of the message.  The length value is
                prepended as a binary form.
                <p />
                For example, <tt>{@link LengthFieldPrepender}(2)</tt> will encode the
                following 12-bytes string:
                <pre>
                    +----------------+
                    | "HELLO, WORLD" |
                    +----------------+
                </pre>
                into the following:
                <pre>
                    +--------+----------------+
                    + 0x000C | "HELLO, WORLD" |
                    +--------+----------------+
                </pre>
                If you turned on the {@code lengthIncludesLengthFieldLength} flag in the
                constructor, the encoded data would look like the following
                (12 (original data) + 2 (prepended data) = 14 (0xE)):
                <pre>
                    +--------+----------------+
                    + 0x000E | "HELLO, WORLD" |
                    +--------+----------------+
                </pre>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender.#ctor(System.Int32)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender.#ctor(System.Int32,System.Boolean)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
            <param name="lengthFieldIncludesLengthFieldLength">
                If <c>true</c>, the length of the prepended length field is added
                to the value of the prepended length field.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender.#ctor(System.Int32,System.Int32)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
            <param name="lengthFieldIncludesLengthFieldLength">
                If <c>true</c>, the length of the prepended length field is added
                to the value of the prepended length field.
            </param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender.#ctor(DotNetty.Buffers.ByteOrder,System.Int32,System.Int32,System.Boolean)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender" /> instance.
            </summary>
            <param name="byteOrder">The <see cref="T:DotNetty.Buffers.ByteOrder" /> of the length field.</param>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
            <param name="lengthFieldIncludesLengthFieldLength">
                If <c>true</c>, the length of the prepended length field is added
                to the value of the prepended length field.
            </param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.LengthFieldPrepender2">
            <summary>
                An encoder that prepends the length of the message.  The length value is
                prepended as a binary form.
                <p />
                For example, <tt>{@link LengthFieldPrepender}(2)</tt> will encode the
                following 12-bytes string:
                <pre>
                    +----------------+
                    | "HELLO, WORLD" |
                    +----------------+
                </pre>
                into the following:
                <pre>
                    +--------+----------------+
                    + 0x000C | "HELLO, WORLD" |
                    +--------+----------------+
                </pre>
                If you turned on the {@code lengthIncludesLengthFieldLength} flag in the
                constructor, the encoded data would look like the following
                (12 (original data) + 2 (prepended data) = 14 (0xE)):
                <pre>
                    +--------+----------------+
                    + 0x000E | "HELLO, WORLD" |
                    +--------+----------------+
                </pre>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender2.#ctor(System.Int32)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender2" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender2.#ctor(System.Int32,System.Boolean)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender2" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
            <param name="lengthFieldIncludesLengthFieldLength">
                If <c>true</c>, the length of the prepended length field is added
                to the value of the prepended length field.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender2.#ctor(System.Int32,System.Int32)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender2" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender2.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
                Creates a new <see cref="T:DotNetty.Codecs.LengthFieldPrepender2" /> instance.
            </summary>
            <param name="lengthFieldLength">
                The length of the prepended length field.
                Only 1, 2, 3, 4, and 8 are allowed.
            </param>
            <param name="lengthFieldIncludesLengthFieldLength">
                If <c>true</c>, the length of the prepended length field is added
                to the value of the prepended length field.
            </param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
        </member>
        <member name="M:DotNetty.Codecs.LengthFieldPrepender2.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.LineBasedFrameDecoder">
            <summary>
                A decoder that splits the received <see cref="T:DotNetty.Buffers.IByteBuffer"/>s on line endings.
                Both {@code "\n"} and {@code "\r\n"} are handled.
                <para>
                The byte stream is expected to be in UTF-8 character encoding or ASCII. The current implementation
                uses direct {@code byte} to {@code char} cast and then compares that {@code char} to a few low range
                ASCII characters like {@code '\n'} or {@code '\r'}. UTF-8 is not using low range [0..0x7F]
                byte values for multibyte codepoint representations therefore fully supported by this implementation.
                </para>
                For a more general delimiter-based decoder, see <see cref="T:DotNetty.Codecs.DelimiterBasedFrameDecoder"/>.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.LineBasedFrameDecoder.maxLength">
            Maximum length of a frame we're willing to decode.  
        </member>
        <member name="F:DotNetty.Codecs.LineBasedFrameDecoder.failFast">
            Whether or not to throw an exception as soon as we exceed maxLength. 
        </member>
        <member name="F:DotNetty.Codecs.LineBasedFrameDecoder.discarding">
            True if we're discarding input because we're already over maxLength.  
        </member>
        <member name="F:DotNetty.Codecs.LineBasedFrameDecoder.offset">
            Last scan position. 
        </member>
        <member name="M:DotNetty.Codecs.LineBasedFrameDecoder.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:DotNetty.Codecs.LineBasedFrameDecoder" /> class.
            </summary>
            <param name="maxLength">
                the maximum length of the decoded frame.
                A {@link TooLongFrameException} is thrown if
                the length of the frame exceeds this value.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LineBasedFrameDecoder.#ctor(System.Int32,System.Boolean,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:DotNetty.Codecs.LineBasedFrameDecoder" /> class.
            </summary>
            <param name="maxLength">
                the maximum length of the decoded frame.
                A {@link TooLongFrameException} is thrown if
                the length of the frame exceeds this value.
            </param>
            <param name="stripDelimiter">
                whether the decoded frame should strip out the
                delimiter or not
            </param>
            <param name="failFast">
                If <tt>true</tt>, a {@link TooLongFrameException} is
                thrown as soon as the decoder notices the length of the
                frame will exceed <tt>maxFrameLength</tt> regardless of
                whether the entire frame has been read.
                If <tt>false</tt>, a {@link TooLongFrameException} is
                thrown after the entire frame that exceeds
                <tt>maxFrameLength</tt> has been read.
            </param>
        </member>
        <member name="M:DotNetty.Codecs.LineBasedFrameDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.LineBasedFrameDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer)">
            <summary>
                Create a frame out of the {@link ByteBuf} and return it.
            </summary>
            <param name="ctx">the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to</param>
            <param name="buffer">the {@link ByteBuf} from which to read data</param>
        </member>
        <member name="M:DotNetty.Codecs.LineBasedFrameDecoder.FindEndOfLine(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Returns the index in the buffer of the end of line found.
            Returns <c>-1</c> if no end of line was found in the buffer.
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Codecs.MessageAggregationException">
            <summary>
            Raised by <see cref="T:DotNetty.Codecs.MessageAggregator`4"/> when aggregation fails due to an unexpected message sequence.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.MessageAggregator`4">
            <summary>
            An abstract <see cref="T:DotNetty.Transport.Channels.IChannelHandler" /> that aggregates a series of message objects 
            into a single aggregated message.
            'A series of messages' is composed of the following:
            a single start message which optionally contains the first part of the content, and
            1 or more content messages. The content of the aggregated message will be the merged 
            content of the start message and its following content messages. If this aggregator 
            encounters a content message where <see cref="M:DotNetty.Codecs.MessageAggregator`4.IsLastContentMessage(`2)"/>
            return true for, the aggregator will finish the aggregation and produce the aggregated 
            message and expect another start message.
            </summary>
            <typeparam name="TMessage">The type that covers both start message and content message</typeparam>
            <typeparam name="TStart">The type of the start message</typeparam>
            <typeparam name="TContent">The type of the content message</typeparam>
            <typeparam name="TOutput">The type of the aggregated message</typeparam>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.#ctor(System.Int32)">
            <summary>Creates a new instance.</summary>
            <param name="maxContentLength">the maximum length of the aggregated content.
            If the length of the aggregated content exceeds this value,
            <see cref="M:DotNetty.Codecs.MessageAggregator`4.HandleOversizedMessage(DotNetty.Transport.Channels.IChannelHandlerContext,`1)"/> will be called.</param>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.AcceptInboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.IsStartMessage(`0)">
            <summary>Returns <c>true</c> if and only if the specified message is a start message.</summary>
            <param name="msg"></param>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.IsContentMessage(`0)">
            <summary>Returns <c>true</c> if and only if the specified message is a content message.</summary>
            <param name="msg"></param>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.IsLastContentMessage(`2)">
            <summary>Returns <c>true</c> if and only if the specified message is the last content message.</summary>
            <param name="msg"></param>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.IsAggregated(`0)">
            <summary>
            Returns <c>true</c> if and only if the specified message is already aggregated.  If this method returns
            <c>true</c>, this handler will simply forward the message to the next handler as-is.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="P:DotNetty.Codecs.MessageAggregator`4.MaxContentLength">
            <summary>
            Returns the maximum allowed length of the aggregated message in bytes.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.MessageAggregator`4.MaxCumulationBufferComponents">
            <summary>
            Gets or sets the maximum number of components in the cumulation buffer.  If the number of
            the components in the cumulation buffer exceeds this value, the components of the
            cumulation buffer are consolidated into a single component, involving memory copies.
            The default value of this property is <see cref="F:DotNetty.Codecs.MessageAggregator`4.DefaultMaxCompositebufferComponents"/>.
            and its minimum allowed value is <code>2</code>.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.IsContentLengthInvalid(`1,System.Int32)">
            <summary>
            Determine if the message <paramref name="start"/>'s content length is known, and if it greater than
            <paramref name="maxContentLength"/>.
            </summary>
            <param name="start">The message which may indicate the content length.</param>
            <param name="maxContentLength">The maximum allowed content length.</param>
            <returns><c>true</c> if the message <paramref name="start"/>'s content length is known, and if it greater than
            <paramref name="maxContentLength"/>. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.NewContinueResponse(`1,System.Int32,DotNetty.Transport.Channels.IChannelPipeline)">
            <summary>
            Returns the 'continue response' for the specified start message if necessary. For example, this method is
            useful to handle an HTTP 100-continue header.
            </summary>
            <param name="start"></param>
            <param name="maxContentLength"></param>
            <param name="pipeline"></param>
            <returns>the 'continue response', or <code>null</code> if there's no message to send</returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.CloseAfterContinueResponse(System.Object)">
            <summary>
            Determine if the channel should be closed after the result of
            <see cref="M:DotNetty.Codecs.MessageAggregator`4.NewContinueResponse(`1,System.Int32,DotNetty.Transport.Channels.IChannelPipeline)"/> is written.
            </summary>
            <param name="msg">The return value from <see cref="M:DotNetty.Codecs.MessageAggregator`4.NewContinueResponse(`1,System.Int32,DotNetty.Transport.Channels.IChannelPipeline)"/>.</param>
            <returns><c>true</c> if the channel should be closed after the result of
            <see cref="M:DotNetty.Codecs.MessageAggregator`4.NewContinueResponse(`1,System.Int32,DotNetty.Transport.Channels.IChannelPipeline)"/> is written. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.IgnoreContentAfterContinueResponse(System.Object)">
            <summary>
            Determine if all objects for the current request/response should be ignored or not.
            Messages will stop being ignored the next time <see cref="M:DotNetty.Codecs.MessageAggregator`4.IsContentMessage(`0)"/> returns <c>true</c>.
            </summary>
            <param name="msg">The return value from <see cref="M:DotNetty.Codecs.MessageAggregator`4.NewContinueResponse(`1,System.Int32,DotNetty.Transport.Channels.IChannelPipeline)"/>.</param>
            <returns><c>true</c> if all objects for the current request/response should be ignored or not.
            <c>false</c> otherwise.</returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.BeginAggregation(`1,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new aggregated message from the specified start message and the specified content.  If the start
            message implements <see cref="T:DotNetty.Buffers.IByteBufferHolder"/>, its content is appended to the specified <typeparamref name="TContent"/>.
            This aggregator will continue to append the received content to the specified <typeparamref name="TContent"/>.
            </summary>
            <param name="start"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.Aggregate(`3,`2)">
            <summary>
            Transfers the information provided by the specified content message to the specified aggregated message.
            Note that the content of the specified content message has been appended to the content of the specified
            aggregated message already, so that you don't need to.  Use this method to transfer the additional information
            that the content message provides to <paramref name="aggregated"/>.
            </summary>
            <param name="aggregated"></param>
            <param name="content"></param>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.FinishAggregation(`3)">
            <summary>
            Invoked when the specified <paramref name="aggregated"/> message is about to be passed to the next handler in the pipeline.
            </summary>
            <param name="aggregated"></param>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.HandleOversizedMessage(DotNetty.Transport.Channels.IChannelHandlerContext,`1)">
            <summary>
            Invoked when an incoming request exceeds the maximum content length.  The default behvaior is to trigger an
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)"/> event with a <see cref="T:DotNetty.Codecs.TooLongFrameException"/>.
            </summary>
            <param name="ctx">the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.</param>
            <param name="oversized">the accumulated message up to this point, whose type is <typeparamref name="TStart"/>
            or <typeparamref name="TOutput"/>.</param>
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageAggregator`4.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.MessageToByteEncoder`1">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/> which encodes message in a stream-like fashion from one message to an
            <see cref="T:DotNetty.Buffers.IByteBuffer"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:DotNetty.Codecs.MessageToByteEncoder`1.AcceptOutboundMessage(System.Object)">
            <summary>
            Returns <c>true</c> if the given message should be handled. If <c>false</c> it will be passed to the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageToByteEncoder`1.Write(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToByteEncoder`1.AllocateBuffer(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Allocate a <see cref="T:DotNetty.Buffers.IByteBuffer"/> which will be used as argument of <see cref="M:DotNetty.Codecs.MessageToByteEncoder`1.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,DotNetty.Buffers.IByteBuffer)"/>.
            Sub-classes may override this method to return <see cref="T:DotNetty.Buffers.IByteBuffer"/> with a perfect matching <c>initialCapacity</c>.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageToByteEncoder`1.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Encode a message into a <see cref="T:DotNetty.Buffers.IByteBuffer"/>. This method will be called for each written message that can be handled
            by this encoder.
            </summary>
            <param name="context">the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> which this <see cref="T:DotNetty.Codecs.MessageToByteEncoder`1"/> belongs to</param>
            <param name="message">the message to encode</param>
            <param name="output">the <see cref="T:DotNetty.Buffers.IByteBuffer"/> into which the encoded message will be written</param>
        </member>
        <member name="T:DotNetty.Codecs.MessageToMessageCodec`2">
             <summary>
             A Codec for on-the-fly encoding/decoding of message.
             
             This can be thought of as a combination of <see cref="T:DotNetty.Codecs.MessageToMessageDecoder`1"/> and <see cref="T:DotNetty.Codecs.MessageToMessageEncoder`1"/>.
             
             Here is an example of a <see cref="T:DotNetty.Codecs.MessageToMessageCodec`2"/> which just decode from {@link Integer} to {@link Long}
             and encode from {@link Long} to {@link Integer}.
             
             <![CDATA[
                 public class NumberCodec extends
                         {@link MessageToMessageCodec}&lt;{@link Integer}, {@link Long}&gt; {
                     {@code @Override}
                     public {@link Long} decode({@link ChannelHandlerContext} ctx, {@link Integer} msg, List&lt;Object&gt; out)
                             throws {@link Exception} {
                         out.add(msg.longValue());
                     }
            
                     {@code @Override}
                     public {@link Integer} encode({@link ChannelHandlerContext} ctx, {@link Long} msg, List&lt;Object&gt; out)
                             throws {@link Exception} {
                         out.add(msg.intValue());
                     }
                 }
             ]]>
             
             Be aware that you need to call <see cref="M:DotNetty.Common.IReferenceCounted.Retain"/> on messages that are just passed through if they
             are of type <see cref="T:DotNetty.Common.IReferenceCounted"/>. This is needed as the <see cref="T:DotNetty.Codecs.MessageToMessageCodec`2"/> will call
             <see cref="M:DotNetty.Common.IReferenceCounted.Release"/> on encoded / decoded messages.
             </summary>
             <typeparam name="TInbound"></typeparam>
             <typeparam name="TOutbound"></typeparam>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.Encoder.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.Encoder.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`1,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.Decoder.AcceptInboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.Decoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.#ctor">
            <summary>
            Create a new instance which will try to detect the types to decode and encode out of the type parameter
            of the class.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.Write(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.AcceptInboundMessage(System.Object)">
            <summary>
            Returns <c>true</c> if and only if the specified message can be decoded by this codec.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.AcceptOutboundMessage(System.Object)">
            <summary>
            Returns <c>true</c> if and only if the specified message can be encoded by this codec.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`1,System.Collections.Generic.List{System.Object})">
            <summary>
            <see cref="M:DotNetty.Codecs.MessageToMessageEncoder`1.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})"/>
            </summary>
            <param name="ctx"></param>
            <param name="msg"></param>
            <param name="output"></param>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageCodec`2.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})">
            <summary>
            <see cref="M:DotNetty.Codecs.MessageToMessageDecoder`1.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})"/>
            </summary>
            <param name="ctx"></param>
            <param name="msg"></param>
            <param name="output"></param>
        </member>
        <member name="T:DotNetty.Codecs.MessageToMessageDecoder`1">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/> which decodes from one message to an other message.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageDecoder`1.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageDecoder`1.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})">
            <summary>
            Decode from one message to an other. This method will be called for each written message that can be handled
            by this decoder.
            </summary>
            <param name="context">the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> which this <see cref="T:DotNetty.Codecs.MessageToMessageDecoder`1"/> belongs to</param>
            <param name="message">the message to decode to an other one</param>
            <param name="output">the <see cref="T:System.Collections.Generic.List`1"/> to which decoded messages should be added</param>
        </member>
        <member name="T:DotNetty.Codecs.MessageToMessageEncoder`1">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/> which encodes from one message to an other message
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageEncoder`1.AcceptOutboundMessage(System.Object)">
            <summary>
            Returns <c>true</c> if the given message should be handled. If <c>false</c> it will be passed to the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageEncoder`1.Write(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.MessageToMessageEncoder`1.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})">
            <summary>
            Encode from one message to an other. This method will be called for each written message that can be handled
            by this encoder.
            </summary>
            <param name="context">the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> which this <see cref="T:DotNetty.Codecs.MessageToMessageEncoder`1"/> belongs to</param>
            <param name="message">the message to encode to an other one</param>
            <param name="output">the <see cref="T:System.Collections.Generic.List`1"/> into which the encoded msg should be added
            needs to do some kind of aggregation</param>
        </member>
        <member name="T:DotNetty.Codecs.Protobuf.ProtobufVarint32FrameDecoder">
            
             A decoder that splits the received {@link ByteBuf}s dynamically by the
             value of the Google Protocol Buffers
             http://code.google.com/apis/protocolbuffers/docs/encoding.html#varints
             Base 128 Varints integer length field in the message. 
             For example:
             
             BEFORE DECODE (302 bytes)       AFTER DECODE (300 bytes)
             +--------+---------------+      +---------------+
             | Length | Protobuf Data |----->| Protobuf Data |
             | 0xAC02 |  (300 bytes)  |      |  (300 bytes)  |
             +--------+---------------+      +---------------+
            
        </member>
        <member name="T:DotNetty.Codecs.Protobuf.ProtobufVarint32LengthFieldPrepender">
            
             An encoder that prepends the the Google Protocol Buffers
             http://code.google.com/apis/protocolbuffers/docs/encoding.html#varints
             Base 128 Varints integer length field. 
             For example:
             
             BEFORE ENCODE (300 bytes)       AFTER ENCODE (302 bytes)
              +---------------+               +--------+---------------+
              | Protobuf Data |-------------->| Length | Protobuf Data |
              |  (300 bytes)  |               | 0xAC02 |  (300 bytes)  |
              +---------------+               +--------+---------------+
        </member>
        <member name="T:DotNetty.Codecs.ProtocolDetectionResult`1">
            <summary>
            Result of detecting a protocol.
            </summary>
            <typeparam name="T">the type of the protocol</typeparam>
        </member>
        <member name="F:DotNetty.Codecs.ProtocolDetectionResult`1.NeedsMoreData">
            <summary>
            Returns a <see cref="T:DotNetty.Codecs.ProtocolDetectionResult`1"/> that signals that more data is needed to detect the protocol.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.ProtocolDetectionResult`1.Invalid">
            <summary>
            Returns a <see cref="T:DotNetty.Codecs.ProtocolDetectionResult`1"/> that signals the data was invalid for the protocol.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ProtocolDetectionResult`1.Detected(`0)">
            <summary>
            Returns a <see cref="T:DotNetty.Codecs.ProtocolDetectionResult`1"/> which holds the detected protocol.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.ProtocolDetectionResult`1.State">
            <summary>
            Return the <see cref="T:DotNetty.Codecs.ProtocolDetectionState"/>. If the state is <see cref="F:DotNetty.Codecs.ProtocolDetectionState.Detected"/> you
            can retrieve the protocol via <see cref="P:DotNetty.Codecs.ProtocolDetectionResult`1.DetectedProtocol"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.ProtocolDetectionResult`1.DetectedProtocol">
            <summary>
            Returns the protocol if <see cref="P:DotNetty.Codecs.ProtocolDetectionResult`1.State"/> returns <see cref="F:DotNetty.Codecs.ProtocolDetectionState.Detected"/>, otherwise <c>null</c>.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.ProtocolDetectionState">
            <summary>
            The state of the current detection.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.ProtocolDetectionState.NeedsMoreData">
            <summary>
            Need more data to detect the protocol.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.ProtocolDetectionState.Invalid">
            <summary>
            The data was invalid.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.ProtocolDetectionState.Detected">
            <summary>
            Protocol was detected.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder.#ctor">
            <summary>Creates a new instance.</summary>
        </member>
        <member name="T:DotNetty.Codecs.ReplayingDecoder`1">
             <summary>
             A specialized variation of <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> which enables implementation
             of a non-blocking decoder in the blocking I/O paradigm.
             <para>
             The biggest difference between <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> and
             <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> is that <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> allows you to
             implement the {@code decode()} and {@code decodeLast()} methods just like
             all required bytes were received already, rather than checking the
             availability of the required bytes.  For example, the following
             <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> implementation:
             </para>
             <code>
             public class IntegerHeaderFrameDecoder extends <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> {
            
               {@code @Override}
               protected void decode(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx,
                                       <see cref="T:DotNetty.Buffers.IByteBuffer"/> buf, List&lt;Object&gt; out) throws Exception {
            
                 if (buf.readableBytes() &lt; 4) {
                    return;
                 }
            
                 buf.markReaderIndex();
                 int length = buf.readInt();
            
                 if (buf.readableBytes() &lt; length) {
                    buf.resetReaderIndex();
                    return;
                 }
            
                 out.add(buf.readBytes(length));
               }
             }
             </code>
             is simplified like the following with <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>:
             <code>
             public class IntegerHeaderFrameDecoder
                  extends <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>&lt;{@link Void}&gt; {
            
               protected void decode(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx,
                                       <see cref="T:DotNetty.Buffers.IByteBuffer"/> buf, List&lt;Object&gt; output) throws Exception {
            
                 out.add(buf.readBytes(buf.readInt()));
               }
             }
             </code>
            
             <h3>How does this work?</h3>
             <para>
             <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> passes a specialized <see cref="T:DotNetty.Buffers.IByteBuffer"/>
             implementation which throws an {@link Error} of certain type when there's not
             enough data in the buffer.  In the {@code IntegerHeaderFrameDecoder} above,
             you just assumed that there will be 4 or more bytes in the buffer when
             you call {@code buf.readInt()}.  If there's really 4 bytes in the buffer,
             it will return the integer header as you expected.  Otherwise, the
             {@link Error} will be raised and the control will be returned to
             <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>.  If <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> catches the
             {@link Error}, then it will rewind the {@code readerIndex} of the buffer
             back to the 'initial' position (i.e. the beginning of the buffer) and call
             the {@code decode(..)} method again when more data is received into the
             buffer.
             </para>
             <para>
             Please note that <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> always throws the same cached
             {@link Error} instance to avoid the overhead of creating a new {@link Error}
             and filling its stack trace for every throw.
             </para>
            
             <h3>Limitations</h3>
             <para>
             At the cost of the simplicity, <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> enforces you a few
             limitations:
             </para>
             <ul>
             <li>Some buffer operations are prohibited.</li>
             <li>Performance can be worse if the network is slow and the message
                 format is complicated unlike the example above.  In this case, your
                 decoder might have to decode the same part of the message over and over
                 again.</li>
             <li>You must keep in mind that {@code decode(..)} method can be called many
                 times to decode a single message.  For example, the following code will
                 not work:
             <code> public class MyDecoder extends <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>&lt;{@link Void}&gt; {
            
               private final Queue&lt;Integer&gt; values = new LinkedList&lt;Integer&gt;();
            
               {@code @Override}
               public void decode(.., <see cref="T:DotNetty.Buffers.IByteBuffer"/> buf, List&lt;Object&gt; out) throws Exception {
            
                 // A message contains 2 integers.
                 values.offer(buf.readInt());
                 values.offer(buf.readInt());
            
                 // This assertion will fail intermittently since values.offer()
                 // can be called more than two times!
                 assert values.size() == 2;
                 out.add(values.poll() + values.poll());
               }
             }</code>
                  The correct implementation looks like the following, and you can also
                  utilize the 'checkpoint' feature which is explained in detail in the
                  next section.
             <code> public class MyDecoder extends <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>&lt;{@link Void}&gt; {
            
               private final Queue&lt;Integer&gt; values = new LinkedList&lt;Integer&gt;();
            
               {@code @Override}
               public void decode(.., <see cref="T:DotNetty.Buffers.IByteBuffer"/> buf, List&lt;Object&gt; out) throws Exception {
            
                 // Revert the state of the variable that might have been changed
                 // since the last partial decode.
                 values.clear();
            
                 // A message contains 2 integers.
                 values.offer(buf.readInt());
                 values.offer(buf.readInt());
            
                 // Now we know this assertion will never fail.
                 assert values.size() == 2;
                 out.add(values.poll() + values.poll());
               }
             }</code>
                 </li>
             </ul>
            
             <h3>Improving the performance</h3>
             <para>
             Fortunately, the performance of a complex decoder implementation can be
             improved significantly with the {@code checkpoint()} method.  The
             {@code checkpoint()} method updates the 'initial' position of the buffer so
             that <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> rewinds the {@code readerIndex} of the buffer
             to the last position where you called the {@code checkpoint()} method.
             </para>
             <h4>Calling {@code checkpoint(T)} with an {@link Enum}</h4>
             <para>
             Although you can just use {@code checkpoint()} method and manage the state
             of the decoder by yourself, the easiest way to manage the state of the
             decoder is to create an {@link Enum} type which represents the current state
             of the decoder and to call {@code checkpoint(T)} method whenever the state
             changes.  You can have as many states as you want depending on the
             complexity of the message you want to decode:
             </para>
             <code>
             public enum MyDecoderState {
               READ_LENGTH,
               READ_CONTENT;
             }
            
             public class IntegerHeaderFrameDecoder
                  extends <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>&lt;<strong>MyDecoderState</strong>&gt; {
            
               private int length;
            
               public IntegerHeaderFrameDecoder() {
                 // Set the initial state.
                 <strong>super(MyDecoderState.READ_LENGTH);</strong>
               }
            
               {@code @Override}
               protected void decode(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx,
                                       <see cref="T:DotNetty.Buffers.IByteBuffer"/> buf, List&lt;Object&gt; out) throws Exception {
                 switch (state()) {
                 case READ_LENGTH:
                   length = buf.readInt();
                   <strong>checkpoint(MyDecoderState.READ_CONTENT);</strong>
                 case READ_CONTENT:
                   ByteBuf frame = buf.readBytes(length);
                   <strong>checkpoint(MyDecoderState.READ_LENGTH);</strong>
                   out.add(frame);
                   break;
                 default:
                   throw new Error("Shouldn't reach here.");
                 }
               }
             }
             </code>
            
             <h4>Calling {@code checkpoint()} with no parameter</h4>
             <para>
             An alternative way to manage the decoder state is to manage it by yourself.
             </para>
             <code>
             public class IntegerHeaderFrameDecoder
                  extends <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>&lt;<strong>{@link Void}</strong>&gt; {
            
               <strong>private boolean readLength;</strong>
               private int length;
            
               {@code @Override}
               protected void decode(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx,
                                       <see cref="T:DotNetty.Buffers.IByteBuffer"/> buf, List&lt;Object&gt; out) throws Exception {
                 if (!readLength) {
                   length = buf.readInt();
                   <strong>readLength = true;</strong>
                   <strong>checkpoint();</strong>
                 }
            
                 if (readLength) {
                   ByteBuf frame = buf.readBytes(length);
                   <strong>readLength = false;</strong>
                   <strong>checkpoint();</strong>
                   out.add(frame);
                 }
               }
             }
             </code>
            
             <h3>Replacing a decoder with another decoder in a pipeline</h3>
             <para>
             If you are going to write a protocol multiplexer, you will probably want to
             replace a <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/> (protocol detector) with another
             <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>, <see cref="T:DotNetty.Codecs.ByteToMessageDecoder"/> or {@link MessageToMessageDecoder}
             (actual protocol decoder).
             It is not possible to achieve this simply by calling
             <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.Replace(DotNetty.Transport.Channels.IChannelHandler,System.String,DotNetty.Transport.Channels.IChannelHandler)"/>, but
             some additional steps are required:
             </para>
             <code>
             public class FirstDecoder extends <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>&lt;{@link Void}&gt; {
            
                 {@code @Override}
                 protected void decode(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx,
                                         <see cref="T:DotNetty.Buffers.IByteBuffer"/> buf, List&lt;Object&gt; out) {
                     ...
                     // Decode the first message
                     Object firstMessage = ...;
            
                     // Add the second decoder
                     ctx.pipeline().addLast("second", new SecondDecoder());
            
                     if (buf.isReadable()) {
                         // Hand off the remaining data to the second decoder
                         out.add(firstMessage);
                         out.add(buf.readBytes(<b>super.actualReadableBytes()</b>));
                     } else {
                         // Nothing to hand off
                         out.add(firstMessage);
                     }
                     // Remove the first decoder (me)
                     ctx.pipeline().remove(this);
                 }
             </code>
             </summary>
             <typeparam name="TState">the state type which is usually an <see cref="T:System.Enum"/>; use <see cref="T:Void"/> if state management is
             unused</typeparam>
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder`1.#ctor">
            <summary>
            Creates a new instance with no initial state (i.e: <c>null</c>).
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder`1.#ctor(`0)">
            <summary>
            Creates a new instance with the specified initial state.
            </summary>
            <param name="initialState"></param>
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder`1.Checkpoint">
            <summary>
            Stores the internal cumulative buffer's reader position.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder`1.Checkpoint(`0)">
            <summary>
            Stores the internal cumulative buffer's reader position and updates
            the current decoder state.
            </summary>
            <param name="newState"></param>
        </member>
        <member name="P:DotNetty.Codecs.ReplayingDecoder`1.State">
            <summary>
            Returns the current state of this decoder.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder`1.ExchangeState(`0)">
            <summary>
            Sets the current state of this decoder.
            </summary>
            <param name="newState"></param>
            <returns>the old state of this decoder</returns>
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder`1.ChannelInputClosed(DotNetty.Transport.Channels.IChannelHandlerContext,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.ReplayingDecoder`1.CallDecode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Buffers.IByteBuffer,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.ReplayingDecoderByteBuffer">
            <summary>
            Special <see cref="T:DotNetty.Buffers.IByteBuffer"/> implementation which is used by the <see cref="T:DotNetty.Codecs.ReplayingDecoder`1"/>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.StringDecoder.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:DotNetty.Codecs.StringDecoder" /> class with the current system
                character set.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.StringDecoder.#ctor(System.Text.Encoding)">
            <summary>
                Initializes a new instance of the <see cref="T:DotNetty.Codecs.StringDecoder" /> class with the specified character
                set..
            </summary>
            <param name="encoding">Encoding.</param>
        </member>
        <member name="T:DotNetty.Codecs.StringEncoder">
             Encodes the requested {@link String} into a {@link ByteBuf}.
             A typical setup for a text-based line protocol in a TCP/IP socket would be:
             <pre>
             {@link ChannelPipeline} pipeline = ...;
            
             // Decoders
             pipeline.addLast("frameDecoder", new {@link LineBasedFrameDecoder}(80));
             pipeline.addLast("stringDecoder", new {@link StringDecoder}(CharsetUtil.UTF_8));
            
             // Encoder
             pipeline.addLast("stringEncoder", new {@link StringEncoder}(CharsetUtil.UTF_8));
             </pre>
             and then you can use a {@link String} instead of a {@link ByteBuf}
             as a message:
             <pre>
             void channelRead({@link ChannelHandlerContext} ctx, {@link String} msg) {
                 ch.write("Did you say '" + msg + "'?\n");
             }
             </pre>
        </member>
        <member name="M:DotNetty.Codecs.StringEncoder.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:DotNetty.Codecs.StringEncoder" /> class with the current system
                character set.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.StringEncoder.#ctor(System.Text.Encoding)">
            <summary>
                Initializes a new instance of the <see cref="T:DotNetty.Codecs.StringEncoder" /> class with the specified character
                set..
            </summary>
            <param name="encoding">Encoding.</param>
        </member>
        <member name="T:DotNetty.Codecs.TooLongFrameException">
            <summary>
                A <see cref="T:DotNetty.Codecs.DecoderException" /> which is thrown when the length of the frame
                decoded is greater than the allowed maximum.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.UnsupportedMessageTypeException">
            <summary>
                Thrown if an unsupported message is received by an codec.
            </summary>
        </member>
    </members>
</doc>
