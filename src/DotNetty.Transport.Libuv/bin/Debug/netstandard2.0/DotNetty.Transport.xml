<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetty.Transport</name>
    </assembly>
    <members>
        <member name="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2">
            <summary>
            This is a helper class that makes it easy to bootstrap an <see cref="T:DotNetty.Transport.Channels.IChannel"/>. It supports method-
            chaining to provide an easy way to configure the <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/>.
            
            When not used in a <see cref="T:DotNetty.Transport.Bootstrapping.ServerBootstrap"/> context, the <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.EndPoint)"/> methods
            are useful for connectionless transports such as datagram (UDP).
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Group(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Specifies the <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which will handle events for the <see cref="T:DotNetty.Transport.Channels.IChannel"/> being built.
            </summary>
            <param name="group">The <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which is used to handle all the events for the to-be-created <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Channel``1">
            <summary>
            Specifies the <see cref="T:System.Type"/> of <see cref="T:DotNetty.Transport.Channels.IChannel"/> which will be created.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> which is used to create <see cref="T:DotNetty.Transport.Channels.IChannel"/> instances from.</typeparam>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.EndPoint)">
            <summary>
            Assigns the <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> instance to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Int32)">
            <summary>
            Assigns the local <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for any IP address on the local machine, given a specific port.
            </summary>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.String,System.Int32)">
            <summary>
            Assigns the local <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            This overload binds to a <see cref="T:System.Net.DnsEndPoint"/> for a given hostname and port.
            </summary>
            <param name="inetHost">The hostname to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            Assigns the local <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for a given <see cref="T:System.Net.IPAddress"/> and port.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Option``1(DotNetty.Transport.Channels.ChannelOption{``0},``0)">
            <summary>
            Allows the specification of a <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> which is used for the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> instances once they get created. Use a value of <c>null</c> to remove
            a previously set <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/>.
            </summary>
            <param name="option">The <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> to configure.</param>
            <param name="value">The value to set the given option.</param>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Attribute``1(DotNetty.Common.Utilities.AttributeKey{``0},``0)">
            <summary>
            Allows specification of an initial attribute of the newly created <see cref="T:DotNetty.Transport.Channels.IChannel" />. If the <c>value</c> is
            <c>null</c>, the attribute of the specified <c>key</c> is removed.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Validate">
            <summary>
            Validates all the parameters. Sub-classes may override this, but should call the super method in that case.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Clone">
            <summary>
            Returns a deep clone of this bootstrap which has the identical configuration.  This method is useful when making
            multiple <see cref="T:DotNetty.Transport.Channels.IChannel"/>s with similar settings.  Please note that this method does not clone the
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> deeply but shallowly, making the group a shared resource.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.RegisterAsync">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and registers it with an <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it to the endpoint specified via the <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.EndPoint)"/> methods.
            </summary>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for any IP address on the local machine, given a specific port.
            </summary>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.String,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            This overload binds to a <see cref="T:System.Net.DnsEndPoint"/> for a given hostname and port.
            </summary>
            <param name="inetHost">The hostname to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for a given <see cref="T:System.Net.IPAddress"/> and port.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.EndPoint)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> instance to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Handler(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Specifies the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to use for serving the requests.
            </summary>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to use for serving requests.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Group">
            <summary>
            Returns the configured <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> or <c>null</c> if none is configured yet.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Bootstrapping.Bootstrap">
            <summary>
            A <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that makes it easy to bootstrap an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to use for clients.
            
            The <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.EndPoint)"/> methods are useful
            in combination with connectionless transports such as datagram (UDP). For regular TCP connections,
            please use the provided <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)"/> methods.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.Resolver(DotNetty.Transport.Bootstrapping.INameResolver)">
            <summary>
            Sets the <see cref="T:DotNetty.Transport.Bootstrapping.INameResolver"/> which will resolve the address of the unresolved named address.
            </summary>
            <param name="resolver">The <see cref="T:DotNetty.Transport.Bootstrapping.INameResolver"/> which will resolve the address of the unresolved named address.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.Net.EndPoint)">
            <summary>
            Assigns the remote <see cref="T:System.Net.EndPoint"/> to connect to once the <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/> method is called.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.String,System.Int32)">
            <summary>
            Assigns the remote <see cref="T:System.Net.EndPoint"/> to connect to once the <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/> method is called.
            </summary>
            <param name="inetHost">The hostname of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            Assigns the remote <see cref="T:System.Net.EndPoint"/> to connect to once the <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/> method is called.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.String,System.Int32)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="inetHost">The hostname of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The local <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.DoResolveAndConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Performs DNS resolution for the remote endpoint and connects to it.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The local <see cref="T:System.Net.EndPoint"/> to connect the remote to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.Clone(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Returns a deep clone of this bootstrap which has the identical configuration except that it uses
            the given <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>. This method is useful when making multiple <see cref="T:DotNetty.Transport.Channels.IChannel"/>s with similar
            settings.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Bootstrapping.ServerBootstrap">
            <summary>
            A <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> sub-class which allows easy bootstrapping of <see cref="T:DotNetty.Transport.Channels.IServerChannel"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.Group(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Specifies the <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which is used for the parent (acceptor) and the child (client).
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.Group(DotNetty.Transport.Channels.IEventLoopGroup,DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Sets the <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> for the parent (acceptor) and the child (client). These
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>'s are used to handle all the events and IO for <see cref="T:DotNetty.Transport.Channels.IServerChannel"/>
            and <see cref="T:DotNetty.Transport.Channels.IChannel"/>'s.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildOption``1(DotNetty.Transport.Channels.ChannelOption{``0},``0)">
            <summary>
            Allows specification of a <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> which is used for the <see cref="T:DotNetty.Transport.Channels.IChannel"/>
            instances once they get created (after the acceptor accepted the <see cref="T:DotNetty.Transport.Channels.IChannel"/>). Use a
            value of <c>null</c> to remove a previously set <see cref="T:DotNetty.Transport.Channels.ChannelOption"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildAttribute``1(DotNetty.Common.Utilities.AttributeKey{``0},``0)">
            <summary>
            Sets the specific <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/> with the given value on every child <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            If the value is <c>null</c>, the <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/> is removed.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildHandler(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Sets the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> which is used to serve the request for the <see cref="T:DotNetty.Transport.Channels.IChannel"/>'s.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildGroup">
            <summary>
            Returns the configured <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which will be used for the child channels or <c>null</c>
            if none is configured yet.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannel`2._strValActive">
            <summary>Cache for the string representation of this channel</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.#ctor(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="parent">The parent of this channel. Pass <c>null</c> if there's no parent.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.#ctor(DotNetty.Transport.Channels.IChannel,DotNetty.Transport.Channels.IChannelId)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="parent">The parent of this channel. Pass <c>null</c> if there's no parent.</param>
            <param name="id">An <see cref="T:DotNetty.Transport.Channels.IChannelId"/> for the new channel.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.InvalidateRemoteAddress">
            <summary>
            Resets the stored <see cref="P:DotNetty.Transport.Channels.AbstractChannel`2.RemoteAddress"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.NewId">
            <summary>
            Returns a new <see cref="T:DotNetty.Transport.Channels.DefaultChannelId"/> instance. Subclasses may override this method to assign custom
            <see cref="T:DotNetty.Transport.Channels.IChannelId"/>s to <see cref="T:DotNetty.Transport.Channels.IChannel"/>s that use the <see cref="T:DotNetty.Transport.Channels.AbstractChannel`2"/> constructor.
            </summary>
            <returns>A new <see cref="T:DotNetty.Transport.Channels.DefaultChannelId"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.NewChannelPipeline">
            <summary>Returns a new pipeline instance.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.NewUnsafe">
            <summary>
            Create a new <see cref="T:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe" /> instance which will be used for the life-time of the
            <see cref="T:DotNetty.Transport.Channels.IChannel" />
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.GetHashCode">
            <summary>
            Returns the ID of this channel.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if and only if the specified object is identical
            with this channel (i.e. <c>this == o</c>).
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.ToString">
            <summary>
            Returns the string representation of this channel. The returned string contains a hex dump of the
            <see cref="T:DotNetty.Transport.Channels.IChannelId"/>, the <see cref="P:DotNetty.Transport.Channels.AbstractChannel`2.LocalAddress"/>, and the <see cref="P:DotNetty.Transport.Channels.AbstractChannel`2.RemoteAddress"/> of this
            channel for easier identification.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.IsCompatible(DotNetty.Transport.Channels.IEventLoop)">
            <summary>
            Checks whether a given <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is compatible with the <see cref="T:DotNetty.Transport.Channels.AbstractChannel`2"/>.
            </summary>
            <param name="eventLoop">The <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> to check compatibility.</param>
            <returns>
            <c>true</c> if the given <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is compatible with this <see cref="T:DotNetty.Transport.Channels.AbstractChannel`2"/>
            instance, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoRegister">
            <summary>
            Is called after the <see cref="T:DotNetty.Transport.Channels.IChannel"/> is registered with its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> as part of the
            register process. Sub-classes may override this method.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoBind(System.Net.EndPoint)">
            <summary>
            Binds the <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the <see cref="T:System.Net.EndPoint"/>.
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to bind.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoDisconnect">
            <summary>
            Disconnects this <see cref="T:DotNetty.Transport.Channels.IChannel"/> from its remote peer.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoClose">
            <summary>
            Closes the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoShutdownOutput">
            <summary>
            Called when conditions justify shutting down the output portion of the channel. This may happen if a write
            operation throws an exception.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoDeregister">
            <summary>
            Deregisters the <see cref="T:DotNetty.Transport.Channels.IChannel"/> from its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>. Sub-classes may override this
            method.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoBeginRead">
            <summary>
            ScheduleAsync a read operation.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)">
            <summary>
            Flush the content of the given buffer to the remote peer.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.FilterOutboundMessage(System.Object)">
            <summary>
            Invoked when a new message is added to a <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/> of this
            <see cref="T:DotNetty.Transport.Channels.AbstractChannel`2"/>, so that the <see cref="T:DotNetty.Transport.Channels.IChannel"/> implementation converts the message to
            another. (e.g. heap buffer -> direct buffer).
            </summary>
            <param name="msg">The message to be filtered.</param>
            <returns>The filtered message.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IChannelUnsafe" /> implementation which sub-classes must extend and use.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe._neverRegistered">
            <summary> true if the channel has never been registered, false otherwise /// </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe.ShutdownOutput(DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Shutdown the output portion of the corresponding <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            For example this will clean up the <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/> and not allow any more writes.
            </summary>
            <param name="promise"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe.ShutdownOutput(DotNetty.Common.Concurrency.IPromise,System.Exception)">
            <summary>
            Shutdown the output portion of the corresponding <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            For example this will clean up the <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/> and not allow any more writes.
            </summary>
            <param name="cause">The cause which may provide rational for the shutdown.</param>
            <param name="promise"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe.Deregister(DotNetty.Common.Concurrency.IPromise)">
            <summary>
            This method must NEVER be called directly, but be executed as an
            extra task with a clean call stack instead. The reason for this
            is that this method calls <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelUnregistered"/>
            directly, which might lead to an unfortunate nesting of independent inbound/outbound
            events. See the comments input <see cref="M:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe.InvokeLater(System.Action)"/> for more details.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel`2.AbstractUnsafe.PrepareToClose">
            <summary>
            Prepares to close the <see cref="T:DotNetty.Transport.Channels.IChannel"/>. If this method returns an <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>, the
            caller must call the <see cref="M:DotNetty.Common.Concurrency.IExecutor.Execute(DotNetty.Common.Concurrency.IRunnable)"/> method with a task that calls
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel`2.DoClose"/> on the returned <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>. If this method returns <c>null</c>,
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel`2.DoClose"/> must be called from the caller thread. (i.e. <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>)
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.AbstractChannelHandlerContext.InvokeHandler">
            <summary>
                Makes best possible effort to detect if <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)" /> was
                called
                yet. If not return <c>false</c> and if called or could not detect return <c>true</c>.
                If this method returns <c>true</c> we will not invoke the <see cref="T:DotNetty.Transport.Channels.IChannelHandler" /> but just forward the
                event.
                This is needed as <see cref="T:DotNetty.Transport.Channels.DefaultChannelPipeline" /> may already put the <see cref="T:DotNetty.Transport.Channels.IChannelHandler" /> in the
                linked-list
                but not called <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)" />
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannelHandlerContext.HandlerState.Init">
            <summary>Neither <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)"/> nor <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)"/> was called.</summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannelHandlerContext.HandlerState.AddPending">
            <summary><see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)"/> is about to be called.</summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannelHandlerContext.HandlerState.AddComplete">
            <summary><see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)"/> was called.</summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannelHandlerContext.HandlerState.RemoveComplete">
            <summary><see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)"/> was called.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.#ctor(DotNetty.Transport.Channels.IChannel,System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="channel">the <see cref="T:DotNetty.Transport.Channels.IChannel"/> which will have the <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/> reflect the amount of queued
            buffers or <c>null</c> if there is no writability state updated.</param>
            <param name="initSize">the initial size of the underlying queue.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Add(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Add a buffer to the end of the queue.
            </summary>
            <param name="buf"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Add(DotNetty.Buffers.IByteBuffer,DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Add a buffer to the end of the queue and associate a promise with it that should be completed when
            all the buffer's bytes have been consumed from the queue and written.
            </summary>
            <param name="buf">to add to the tail of the queue</param>
            <param name="promise">to complete when all the bytes have been consumed and written, can be void.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.RemoveFirst(DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Remove the first <see cref="T:DotNetty.Buffers.IByteBuffer"/> from the queue.
            </summary>
            <param name="aggregatePromise">used to aggregate the promises and listeners for the returned buffer.</param>
            <returns>the first <see cref="T:DotNetty.Buffers.IByteBuffer"/> from the queue.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Remove(DotNetty.Buffers.IByteBufferAllocator,System.Int32,DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Remove a <see cref="T:DotNetty.Buffers.IByteBuffer"/> from the queue with the specified number of bytes. Any added buffer who's bytes are
            fully consumed during removal will have it's promise completed when the passed aggregate <see cref="T:DotNetty.Common.Concurrency.IPromise"/>
            completes.
            </summary>
            <param name="alloc">The allocator used if a new <see cref="T:DotNetty.Buffers.IByteBuffer"/> is generated during the aggregation process.</param>
            <param name="bytes">the maximum number of readable bytes in the returned <see cref="T:DotNetty.Buffers.IByteBuffer"/>, if {@code bytes} is greater
            than <see cref="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ReadableBytes"/> then a buffer of length <see cref="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ReadableBytes"/> is returned.</param>
            <param name="aggregatePromise">used to aggregate the promises and listeners for the constituent buffers.</param>
            <returns>a <see cref="T:DotNetty.Buffers.IByteBuffer"/> composed of the enqueued buffers.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ReadableBytes">
            <summary>
            The number of readable bytes.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.IsEmpty">
            <summary>
            Are there pending buffers in the queue.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ReleaseAndFailAll(System.Exception)">
            <summary>
            Release all buffers in the queue and complete all listeners and promises.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.CopyTo(DotNetty.Transport.Channels.AbstractCoalescingBufferQueue)">
            <summary>
            Copy all pending entries in this queue into the destination queue.
            </summary>
            <param name="dest">to copy pending buffers to.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.WriteAndRemoveAll(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Writes all remaining elements in this queue.
            </summary>
            <param name="ctx">The context to write all elements to.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Compose(DotNetty.Buffers.IByteBufferAllocator,DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Calculate the result of {@code current + next}.
            </summary>
            <param name="alloc"></param>
            <param name="cumulation"></param>
            <param name="next"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ComposeIntoComposite(DotNetty.Buffers.IByteBufferAllocator,DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Compose <paramref name="cumulation"/> and <paramref name="next"/> into a new <see cref="T:DotNetty.Buffers.CompositeByteBuffer"/>.
            </summary>
            <param name="alloc"></param>
            <param name="cumulation"></param>
            <param name="next"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.CopyAndCompose(DotNetty.Buffers.IByteBufferAllocator,DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Compose <paramref name="cumulation"/> and <paramref name="next"/> into a new <see cref="M:DotNetty.Buffers.IByteBufferAllocator.Buffer(System.Int32)"/>.
            </summary>
            <param name="alloc">The allocator to use to allocate the new buffer.</param>
            <param name="cumulation">The current cumulation.</param>
            <param name="next">The next buffer.</param>
            <returns>The result of <code>cumulation + next</code>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ComposeFirst(DotNetty.Buffers.IByteBufferAllocator,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Calculate the first <see cref="T:DotNetty.Buffers.IByteBuffer"/> which will be used in subsequent calls to
            <see cref="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Compose(DotNetty.Buffers.IByteBufferAllocator,DotNetty.Buffers.IByteBuffer,DotNetty.Buffers.IByteBuffer)"/>
            </summary>
            <param name="allocator"></param>
            <param name="first"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.RemoveEmptyValue">
            <summary>
            The value to return when <see cref="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Remove(DotNetty.Buffers.IByteBufferAllocator,System.Int32,DotNetty.Common.Concurrency.IPromise)"/> is called but the queue is empty.
            </summary>
            <returns>the <see cref="T:DotNetty.Buffers.IByteBuffer"/> which represents an empty queue.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Size">
            <summary>
            Get the number of elements in this queue added via one of the <see cref="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.Add(DotNetty.Buffers.IByteBuffer)"/> methods.
            </summary>
            <returns>the number of elements in this queue.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.AbstractServerChannel`2">
            <summary>
            A skeletal server-side <see cref="T:DotNetty.Transport.Channels.IChannel"/> implementation. A server-side <see cref="T:DotNetty.Transport.Channels.IChannel"/> does not
            allow the following operations: <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)"/>,
            <see cref="M:DotNetty.Transport.Channels.IChannel.DisconnectAsync"/>, <see cref="M:DotNetty.Transport.Channels.IChannel.WriteAsync(System.Object)"/>,
            <see cref="M:DotNetty.Transport.Channels.IChannel.Flush"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractServerChannel`2.#ctor">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.AdaptiveRecvByteBufAllocator">
            <summary>
                The <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocator" /> that automatically increases and
                decreases the predicted buffer size on feed back.
                <p />
                It gradually increases the expected number of readable bytes if the previous
                read fully filled the allocated buffer. It gradually decreases the expected
                number of readable bytes if the read operation was not able to fill a certain
                amount of the allocated buffer two times consecutively. Otherwise, it keeps
                returning the same prediction.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AdaptiveRecvByteBufAllocator.#ctor">
            <summary>
                Creates a new predictor with the default parameters.  With the default
                parameters, the expected buffer size starts from <c>1024</c>, does not
                go down below <c>64</c>, and does not go up above <c>65536</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AdaptiveRecvByteBufAllocator.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Creates a new predictor with the specified parameters.</summary>
            <param name="minimum">the inclusive lower bound of the expected buffer size</param>
            <param name="initial">the initial buffer size when no feed back was received</param>
            <param name="maximum">the inclusive upper bound of the expected buffer size</param>
        </member>
        <member name="T:DotNetty.Transport.Channels.AffinitizedEventLoopGroup">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> that works as a wrapper for another <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> providing affinity on <see cref="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.GetNext"/> call.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.TerminationCompletion">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>
        </member>
        <member name="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.#ctor(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Creates a new instance of <see cref="T:DotNetty.Transport.Channels.AffinitizedEventLoopGroup"/>.
            </summary>
            <param name="innerGroup"><see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> serving as an actual provider of <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>s.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.GetNext">
            <summary>
            If running in a context of an existing <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>, this <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is returned.
            Otherwise, <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is retrieved from underlying <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>
        </member>
        <member name="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue">
            <summary>
                A queue of write operations which are pending for later execution. It also updates the
                <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable">writability</see> of the associated <see cref="T:DotNetty.Transport.Channels.IChannel" />, so that
                the pending write operations are also considered to determine the writability.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.BatchingPendingWriteQueue.IsEmpty">
            <summary>Returns <c>true</c> if there are no pending write operations left in this queue.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Size">
            <summary>Returns the number of pending write operations.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Add(System.Object,DotNetty.Common.Concurrency.IPromise)">
            <summary>Add the given <c>msg</c> and returns <see cref="T:System.Threading.Tasks.Task" /> for completion of processing <c>msg</c>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndFailAll(System.Exception)">
            <summary>
                Remove all pending write operation and fail them with the given <see cref="T:System.Exception" />. The messages will be
                released
                via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndFail(System.Exception)">
            <summary>
                Remove a pending write operation and fail it with the given <see cref="T:System.Exception" />. The message will be released
                via
                <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndWriteAllAsync">
            <summary>
                Remove all pending write operation and performs them via
                <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object,DotNetty.Common.Concurrency.IPromise)" />.
            </summary>
            <returns>
                <see cref="T:System.Threading.Tasks.Task" /> if something was written and <c>null</c> if the <see cref="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue" />
                is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndWriteAsync">
            <summary>
                Removes a pending write operation and performs it via
                <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object,DotNetty.Common.Concurrency.IPromise)"/>.
            </summary>
            <returns>
                <see cref="T:System.Threading.Tasks.Task" /> if something was written and <c>null</c> if the <see cref="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue" />
                is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Remove">
            <summary>
                Removes a pending write operation and release it's message via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <returns><see cref="T:DotNetty.Common.Concurrency.IPromise" /> of the pending write or <c>null</c> if the queue is empty.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Current">
            <summary>
                Return the current message or <c>null</c> if empty.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue.PendingWrite">
            <summary>Holds all meta-data and construct the linked-list structure.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.ChannelDuplexHandler">
            <summary>
            It is a good starting point if your <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> implementation needs to intercept operations and also
            state updates.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.ChannelInitializer`1">
            <summary>
            A special <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> which offers an easy way to initialize a <see cref="T:DotNetty.Transport.Channels.IChannel"/> once it was
            registered to its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            <para>
            Implementations are most often used in the context of <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Handler(DotNetty.Transport.Channels.IChannelHandler)"/>
            and <see cref="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildHandler(DotNetty.Transport.Channels.IChannelHandler)"/> to setup the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of a <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            Be aware that this class is marked as Sharable (via <see cref="P:DotNetty.Transport.Channels.ChannelInitializer`1.IsSharable"/>) and so the implementation must be safe to be re-used.
            </summary>
            <example>
            <code>
            public class MyChannelInitializer extends <see cref="T:DotNetty.Transport.Channels.ChannelInitializer`1"/> {
                public void InitChannel(<see cref="T:DotNetty.Transport.Channels.IChannel"/> channel) {
                    channel.Pipeline().AddLast("myHandler", new MyHandler());
                }
            }
            <see cref="T:DotNetty.Transport.Bootstrapping.ServerBootstrap"/> bootstrap = ...;
            ...
            bootstrap.childHandler(new MyChannelInitializer());
            ...
            </code>
            </example>
            <typeparam name="T">A sub-type of <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</typeparam>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelInitializer`1.InitChannel(`0)">
            <summary>
            This method will be called once the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was registered. After the method returns this instance
            will be removed from the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> which was registered.</param>
        </member>
        <member name="T:DotNetty.Transport.Channels.ChannelMetadata">
            <summary>Represents the properties of a <see cref="T:DotNetty.Transport.Channels.IChannel" /> implementation.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelMetadata.#ctor(System.Boolean)">
            <summary>Create a new instance</summary>
            <param name="hasDisconnect">
                <c>true</c> if and only if the channel has the <c>DisconnectAsync()</c> operation
                that allows a user to disconnect and then call <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)" />
                again, such as UDP/IP.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelMetadata.#ctor(System.Boolean,System.Int32)">
            <summary>Create a new instance</summary>
            <param name="hasDisconnect">
                <c>true</c> if and only if the channel has the <c>DisconnectAsync</c> operation
                that allows a user to disconnect and then call <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)" />
                again, such as UDP/IP.
            </param>
            <param name="defaultMaxMessagesPerRead">
                If a <see cref="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator" /> is in use, then this value will be
                set for <see cref="P:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator.MaxMessagesPerRead" />. Must be <c> &gt; 0</c>.
            </param>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelMetadata.HasDisconnect">
            <summary>
                Returns <c>true</c> if and only if the channel has the <c>DisconnectAsync()</c> operation
                that allows a user to disconnect and then call <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)" /> again,
                such as UDP/IP.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelMetadata.DefaultMaxMessagesPerRead">
            <summary>
                If a <see cref="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator" /> is in use, then this is the default value for
                <see cref="P:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator.MaxMessagesPerRead" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.ValueOf``1(System.String)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> of the specified name.
            </summary>
            <typeparam name="T">The type of option being retrieved.</typeparam>
            <param name="name">The name of the desired option.</param>
            <returns>The matching <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.ValueOf``1(System.Type,System.String)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> of the given pair: (<see cref="T:System.Type"/>, secondary name)
            </summary>
            <typeparam name="T">The type of option being retrieved.</typeparam>
            <param name="firstNameComponent">
            A <see cref="T:System.Type"/> whose name will be used as the first part of the desired option's name.
            </param>
            <param name="secondNameComponent">
            A string representing the second part of the desired option's name.
            </param>
            <returns>The matching <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.Exists(System.String)">
            <summary>
            Checks whether a given <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> exists.
            </summary>
            <param name="name">The name of the <see cref="T:DotNetty.Transport.Channels.ChannelOption"/>.</param>
            <returns><c>true</c> if a <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> exists for the given <paramref name="name"/>, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.NewInstance``1(System.String)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> for the given <paramref name="name"/>.
            </summary>
            <typeparam name="T">The type of option to create.</typeparam>
            <param name="name">The name to associate with the new option.</param>
            <exception cref="T:System.ArgumentException">Thrown if a <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> for the given <paramref name="name"/> exists.</exception>
            <returns>The new <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.AddMessage(System.Object,System.Int32,DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Adds the given message to this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>. The given
            <see cref="T:DotNetty.Common.Concurrency.IPromise"/> will be notified once the message was written.
            </summary>
            <param name="msg">The message to add to the buffer.</param>
            <param name="size">The size of the message.</param>
            <param name="promise">The <see cref="T:DotNetty.Common.Concurrency.IPromise"/> to notify once the message is written.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.AddFlush">
            <summary>
            Add a flush to this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>. This means all previous added messages are marked
            as flushed and so you will be able to handle them.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IncrementPendingOutboundBytes(System.Int64)">
            <summary>
            Increments the number of pending bytes which will be written at some point.
            This method is thread-safe!
            </summary>
            <param name="size">The number of bytes to increment the count by.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.DecrementPendingOutboundBytes(System.Int64)">
            <summary>
            Decrements the number of pending bytes which will be written at some point.
            This method is thread-safe!
            </summary>
            <param name="size">The number of bytes to decrement the count by.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.Current">
            <summary>
            Returns the current message to write, or <c>null</c> if nothing was flushed before and so is ready to be
            written.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.CurrentProgress">
            <summary>
            Return the current message flush progress.
            </summary>
            <returns><c>0</c> if nothing was flushed before for the current message or there is no current message</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.Progress(System.Int64)">
            <summary>
            Notify the <see cref="T:DotNetty.Common.Concurrency.IPromise"/> of the current message about writing progress.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.Remove">
            <summary>
            Removes the current message, marks its <see cref="T:DotNetty.Common.Concurrency.IPromise"/> as complete, and returns
            <c>true</c>. If no flushed message exists at the time this method is called, it returns <c>false</c> to
            signal that no more messages are ready to be handled.
            </summary>
            <returns><c>true</c> if a message existed and was removed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.Remove(System.Exception)">
            <summary>
            Removes the current message, marks its <see cref="T:DotNetty.Common.Concurrency.IPromise"/> as complete using the given
            <see cref="T:System.Exception"/>, and returns <c>true</c>. If no flushed message exists at the time this method is
            called, it returns <c>false</c> to signal that no more messages are ready to be handled.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> causing the message to be removed.</param>
            <returns><c>true</c> if a message existed and was removed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.RemoveBytes(System.Int64)">
            <summary>
            Removes the fully written entries and updates the reader index of the partially written entry.
            This operation assumes all messages in this buffer are <see cref="T:DotNetty.Buffers.IByteBuffer"/> instances.
            </summary>
            <param name="writtenBytes">The number of bytes that have been written so far.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.ClearNioBuffers">
            <summary>
            Clears all ByteBuffer from the array so these can be GC'ed.
            See https://github.com/netty/netty/issues/3837
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList">
            <summary>
            Returns a list of direct ArraySegment&lt;byte&gt;, if the currently pending messages are made of
            <see cref="T:DotNetty.Buffers.IByteBuffer"/> instances only. <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.NioBufferSize"/> will return the total number of
            readable bytes of these buffers.
            <para>
            Note that the returned array is reused and thus should not escape
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel`2.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/>. Refer to
            <see cref="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel`1.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/> for an example.
            </para>
            </summary>
            <returns>A list of ArraySegment&lt;byte&gt; buffers.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList(System.Int32,System.Int64)">
            <summary>
            Returns a list of direct ArraySegment&lt;byte&gt;, if the currently pending messages are made of
            <see cref="T:DotNetty.Buffers.IByteBuffer"/> instances only. <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.NioBufferSize"/> will return the total number of
            readable bytes of these buffers.
            <para>
            Note that the returned array is reused and thus should not escape
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel`2.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/>. Refer to
            <see cref="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel`1.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/> for an example.
            </para>
            </summary>
            <param name="maxCount">The maximum amount of buffers that will be added to the return value.</param>
            <param name="maxBytes">A hint toward the maximum number of bytes to include as part of the return value. Note that this value maybe exceeded because we make a best effort to include at least 1 <see cref="T:DotNetty.Buffers.IByteBuffer"/> in the return value to ensure write progress is made.</param>
            <returns>A list of ArraySegment&lt;byte&gt; buffers.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.NioBufferSize">
            <summary>
            Returns the number of bytes that can be written out of the <see cref="T:DotNetty.Buffers.IByteBuffer"/> array that was
            obtained via <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList"/>. This method <strong>MUST</strong> be called after
            <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable">
            <summary>
            Returns <c>true</c> if and only if the total number of pending bytes (<see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.TotalPendingWriteBytes"/>)
            did not exceed the write watermark of the <see cref="T:DotNetty.Transport.Channels.IChannel"/> and no user-defined writability flag
            (<see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.SetUserDefinedWritability(System.Int32,System.Boolean)"/>) has been set to <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetUserDefinedWritability(System.Int32)">
            <summary>
            Returns <c>true</c> if and only if the user-defined writability flag at the specified index is set to
            <c>true</c>.
            </summary>
            <param name="index">The index to check for user-defined writability.</param>
            <returns>
            <c>true</c> if the user-defined writability flag at the specified index is set to <c>true</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.SetUserDefinedWritability(System.Int32,System.Boolean)">
            <summary>
            Sets a user-defined writability flag at the specified index.
            </summary>
            <param name="index">The index where a writability flag should be set.</param>
            <param name="writable">Whether to set the index as writable or not.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.Size">
            <summary>
            Returns the number of flushed messages in this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsEmpty">
            <summary>
            Returns <c>true</c> if there are flushed messages in this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.BytesBeforeUnwritable">
            <summary>
            Gets the number of bytes that can be written before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> returns <c>false</c>.
            This quantity will always be non-negative. If <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> is already <c>false</c>, then 0 is
            returned.
            </summary>
            <returns>
            The number of bytes that can be written before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> returns <c>false</c>.
            </returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.BytesBeforeWritable">
            <summary>
            Gets the number of bytes that must be drained from the underlying buffer before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/>
            returns <c>true</c>. This quantity will always be non-negative. If <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> is already
            <c>true</c>, then 0 is returned.
            </summary>
            <returns>
            The number of bytes that can be written before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> returns <c>true</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.ForEachFlushedMessage(DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor)">
            <summary>
            Calls <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor.ProcessMessage(System.Object)"/> for each flushed message in this
            <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/> until <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor.ProcessMessage(System.Object)"/> returns
            <c>false</c> or there are no more flushed messages to process.
            </summary>
            <param name="processor">
            The <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor"/> intance to use to process each flushed message.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor.ProcessMessage(System.Object)">
            <summary>
            Will be called for each flushed message until it either there are no more flushed messages or this method returns <c>false</c>.
            </summary>
            <param name="msg">The message to process.</param>
            <returns><c>true</c> if the given message was successfully processed, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.CoalescingBufferQueue">
            <summary>
            A FIFO queue of bytes where producers add bytes by repeatedly adding <see cref="T:DotNetty.Buffers.IByteBuffer"/> and consumers take bytes in
            arbitrary lengths. This allows producers to add lots of small buffers and the consumer to take all the bytes
            out in a single buffer. Conversely the producer may add larger buffers and the consumer could take the bytes in
            many small buffers.
            <para>
            Bytes are added and removed with promises. If the last byte of a buffer added with a promise is removed then
            that promise will complete when the promise passed to <see cref="M:DotNetty.Transport.Channels.CoalescingBufferQueue.Remove(System.Int32,DotNetty.Common.Concurrency.IPromise)"/> completes.
            </para>
            <para>This functionality is useful for aggregating or partitioning writes into fixed size buffers for framing protocols
            such as HTTP2.</para>
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.CoalescingBufferQueue.Remove(System.Int32,DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Remove a <see cref="T:DotNetty.Buffers.IByteBuffer"/> from the queue with the specified number of bytes. Any added buffer who's bytes are
            fully consumed during removal will have it's promise completed when the passed aggregate <see cref="T:DotNetty.Common.Concurrency.IPromise"/>
            completes.
            </summary>
            <param name="bytes">the maximum number of readable bytes in the returned <see cref="T:DotNetty.Buffers.IByteBuffer"/>, if <paramref name="bytes"/> is greater
            than <see cref="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ReadableBytes"/> then a buffer of length <see cref="M:DotNetty.Transport.Channels.AbstractCoalescingBufferQueue.ReadableBytes"/> is returned.</param>
            <param name="aggregatePromise">used to aggregate the promises and listeners for the constituent buffers.</param>
            <returns>a <see cref="T:DotNetty.Buffers.IByteBuffer"/> composed of the enqueued buffers.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.DefaultChannelConfiguration">
            <summary>
                Shared configuration for SocketAsyncChannel. Provides access to pre-configured resources like ByteBuf allocator and
                IO buffer pools
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.DefaultChannelPipeline._pendingHandlerCallbackHead">
            <summary>
            This is the head of a linked list that is processed by <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.CallHandlerAddedForAllHandlers" /> and so
            process all the pending <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.CallHandlerAdded0(DotNetty.Transport.Channels.AbstractChannelHandlerContext)" />. We only keep the head because it is expected that
            the list is used infrequently and its size is small. Thus full iterations to do insertions is assumed to be
            a good compromised to saving memory and tail management complexity.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.DefaultChannelPipeline._registered">
            <summary>
            Set to <c>true</c> once the <see cref="T:DotNetty.Transport.Channels.AbstractChannel`2" /> is registered. Once set to <c>true</c>, the
            value will never change.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.AtomicRemoveFromHandlerList(DotNetty.Transport.Channels.AbstractChannelHandlerContext)">
            <summary>
            Method is synchronized to make the handler removal from the double linked list atomic.
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.ToString">
            <summary>
            Returns the string representation of this pipeline.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.Destroy">
            <summary>
            Removes all handlers from the pipeline one by one from tail (exclusive) to head (exclusive) to trigger
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)"/>. Note that we traverse up the pipeline <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.DestroyUp(DotNetty.Transport.Channels.AbstractChannelHandlerContext,System.Boolean)"/>
            before traversing down <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.DestroyDown(DotNetty.Common.Concurrency.XThread,DotNetty.Transport.Channels.AbstractChannelHandlerContext,System.Boolean)"/> so that the handlers are removed after all events are
            handled.
            See: https://github.com/netty/netty/issues/3156
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundException(System.Exception)">
            <summary>
            Called once an <see cref="T:System.Exception" /> hits the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" /> without being
            handled by the user in <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundChannelActive">
            <summary>
            Called once the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelActive(DotNetty.Transport.Channels.IChannelHandlerContext)" /> event hit
            the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundChannelInactive">
            <summary>
            Called once the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)" /> event hit
            the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundMessage(System.Object)">
            <summary>
            Called once a message hits the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" /> without being handled by the user
            in <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)" />. This method is responsible
            for calling <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)" /> on the given msg at some point.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundChannelReadComplete">
            <summary>
            Called once the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)" /> event hit
            the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundUserEventTriggered(System.Object)">
            <summary>
            Called once an user event hit the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" /> without been handled by the user
            in <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)" />. This method is responsible
            to call <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)" /> on the given event at some point.
            </summary>
            <param name="evt"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledChannelWritabilityChanged">
            <summary>
            Called once the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelWritabilityChanged(DotNetty.Transport.Channels.IChannelHandlerContext)" /> event hit
            the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator">
            <summary>
                Default implementation of <see cref="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator" /> which respects
                <see cref="P:DotNetty.Transport.Channels.IChannelConfiguration.AutoRead" />
                and also prevents overflow.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle`1">
            <summary>Focuses on enforcing the maximum messages per read condition for <see cref="M:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle`1.ContinueReading" />.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle`1.Reset(DotNetty.Transport.Channels.IChannelConfiguration)">
            <summary>Only <see cref="M:IChannelConfiguration.MaxMessagesPerRead" /> is used.</summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.DefaultMessageSizeEstimator.Default">
            <summary>
            Returns the default implementation, which returns <c>8</c> for unknown messages.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultMessageSizeEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="unknownSize">The size which is returned for unknown messages.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor">
            <summary>
                Create a new instance with an empty pipeline.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor(DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
                Create a new instance with the pipeline initialized with the specified handlers.
            </summary>
            <param name="handlers">
                The <see cref="T:DotNetty.Transport.Channels.IChannelHandler" />s that will be added to the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor(DotNetty.Transport.Channels.IChannelId)">
            <summary>
                Create a new instance with an empty pipeline with the specified <see cref="T:DotNetty.Transport.Channels.IChannelId" />.
            </summary>
            <param name="channelId">The <see cref="T:DotNetty.Transport.Channels.IChannelId" /> of this channel. </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor(DotNetty.Transport.Channels.IChannelId,System.Boolean,DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>Create a new instance with the pipeline initialized with the specified handlers.</summary>
            <param name="id">The <see cref="T:DotNetty.Transport.Channels.IChannelId" /> of this channel.</param>
            <param name="hasDisconnect">
                <c>false</c> if this <see cref="T:DotNetty.Transport.Channels.IChannel" /> will delegate <see cref="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.DisconnectAsync" />
                to <see cref="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.CloseAsync" />, <c>true</c> otherwise.
            </param>
            <param name="handlers">
                The <see cref="T:DotNetty.Transport.Channels.IChannelHandler" />s that will be added to the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />
            </param>
        </member>
        <member name="P:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.InboundMessages">
            <summary>
                Returns the <see cref="T:System.Collections.Generic.Queue`1" /> which holds all of the <see cref="T:System.Object" />s that
                were received by this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.OutboundMessages">
            <summary>
                Returns the <see cref="T:System.Collections.Generic.Queue`1" /> which holds all of the <see cref="T:System.Object" />s that
                were written by this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReadInbound``1">
            <summary>
            Return received data from this <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReadOutbound``1">
            <summary>
            Read data from the outbound. This may return <c>null</c> if nothing is readable.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.RunPendingTasks">
            <summary>
                Run all tasks (which also includes scheduled tasks) that are pending in the <see cref="T:DotNetty.Transport.Channels.IEventLoop" />
                for this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.RunScheduledPendingTasks">
            <summary>
                Run all pending scheduled tasks in the <see cref="T:DotNetty.Transport.Channels.IEventLoop" /> for this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
            <returns>
                The <see cref="T:DotNetty.Common.PreciseTimeSpan" /> when the next scheduled task is ready to run. If no other task is
                scheduled then it will return <see cref="F:DotNetty.Common.PreciseTimeSpan.Zero" />.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.WriteInbound(System.Object[])">
            <summary>
                Write messages to the inbound of this <see cref="T:DotNetty.Transport.Channels.IChannel" />
            </summary>
            <param name="msgs">The messages to be written.</param>
            <returns><c>true</c> if the write operation did add something to the inbound buffer</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.FlushInbound">
            <summary>Flushes the inbound of this <see cref="T:DotNetty.Transport.Channels.IChannel"/>. This method is conceptually equivalent to Flush.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.FlushInbound(System.Boolean,DotNetty.Common.Concurrency.IPromise)">
            <summary>Flushes the inbound of this <see cref="T:DotNetty.Transport.Channels.IChannel"/>. This method is conceptually equivalent to Flush.</summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.WriteOutbound(System.Object[])">
            <summary>
                Write messages to the outbound of this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
            <param name="msgs">The messages to be written.</param>
            <returns><c>true</c> if the write operation did add something to the inbound buffer</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.WriteOneOutbound(System.Object)">
            <summary>
            Writes one message to the outbound of this <see cref="T:DotNetty.Transport.Channels.IChannel"/> and does not flush it. This
            method is conceptually equivalent to WriteAsync.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.FlushOutbound">
            <summary>Flushes the outbound of this <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            This method is conceptually equivalent to <see cref="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.Finish"/>.</summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.Finish">
            <summary>
                Mark this <see cref="T:DotNetty.Transport.Channels.IChannel" /> as finished. Any further try to write data to it will fail.
            </summary>
            <returns>bufferReadable returns <c>true</c></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.FinishAndReleaseAll">
            <summary>
            Marks this <see cref="T:DotNetty.Transport.Channels.IChannel"/> as finished and releases all pending message in the inbound and outbound
            buffer. Any futher try to write data to it will fail.
            </summary>
            <returns><c>true</c> if any of the used buffers has something left to read, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.Finish(System.Boolean)">
            <summary>
            Marks this <see cref="T:DotNetty.Transport.Channels.IChannel"/> as finished. Any futher attempt to write data to it will fail.
            </summary>
            <param name="releaseAll">If <c>true</c>, all pending messages in the inbound and outbound buffer are released.</param>
            <returns><c>true</c> if any of the used buffers has something left to read, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReleaseInbound">
            <summary>
            Releases all buffered inbound messages.
            </summary>
            <returns><c>true</c> if any were in the inbound buffer, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReleaseOutbound">
            <summary>
            Releases all buffered outbound messages.
            </summary>
            <returns><c>true</c> if any were in the outbound buffer, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.CheckException(DotNetty.Common.Concurrency.IPromise)">
            <summary>
                Check to see if there was any <see cref="T:System.Exception" /> and rethrow if so.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.CheckOpen(System.Boolean)">
            <summary>Returns <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel" /> is open and records optionally
            an <see cref="T:System.Exception" /> if it isn't.</summary>
            <param name="recordException"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.EnsureOpen">
            <summary>
                Ensure the <see cref="T:DotNetty.Transport.Channels.IChannel" /> is open and if not throw an exception.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.HandleOutboundMessage(System.Object)">
            <summary>Called for each outbound message.</summary>
            <param name="msg"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.HandleInboundMessage(System.Object)">
            <summary>Called for each inbound message.</summary>
            <param name="msg"></param>
        </member>
        <member name="T:DotNetty.Transport.Channels.Embedded.EmbeddedChannelId">
            <summary>
                A dummy <see cref="T:DotNetty.Transport.Channels.IChannelId" /> implementation
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.FixedRecvByteBufAllocator">
            <summary>
                The <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocator" /> that always yields the same buffer
                size prediction. This predictor ignores the feedback from the I/O thread.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.FixedRecvByteBufAllocator.#ctor(System.Int32)">
            <summary>
                Creates a new predictor that always returns the same prediction of
                the specified buffer size.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Groups.IChannelGroup.Name">
            <summary>
                Returns the name of this group.  A group name is purely for helping
                you to distinguish one group from others.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IChannel">
             <summary>
             A nexus to a network socket or a component which is capable of I/O
             operations such as read, write, connect, and bind.
             <para>
             A channel provides a user:
             <ul>
             <li>the current state of the channel (e.g. is it open? is it connected?),</li>
             <li>the <see cref="T:DotNetty.Transport.Channels.IChannelConfiguration"/> configuration parameters of the channel (e.g. receive buffer size),</li>
             <li>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and</li>
             <li>the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> which handles all I/O events and requests
                 associated with the channel.</li>
             </ul>
            
             <h3>All I/O operations are asynchronous.</h3>
             </para>
             All I/O operations in Netty are asynchronous.  It means any I/O calls will
             return immediately with no guarantee that the requested I/O operation has
             been completed at the end of the call.  Instead, you will be returned with
             a <see cref="T:System.Threading.Tasks.Task"/> instance which will notify you when the requested I/O
             operation has succeeded, failed, or canceled.
            
             <h3>Channels are hierarchical</h3>
             <para>
             A <see cref="T:DotNetty.Transport.Channels.IChannel"/> can have a <see cref="P:DotNetty.Transport.Channels.IChannel.Parent"/> depending on
             how it was created.  For instance, a <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel"/>, that was accepted
             by <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel"/>, will return the <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel"/>
             as its parent on <see cref="P:DotNetty.Transport.Channels.IChannel.Parent"/>.
             </para>
             The semantics of the hierarchical structure depends on the transport
             implementation where the <see cref="T:DotNetty.Transport.Channels.IChannel"/> belongs to.  For example, you could
             write a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> implementation that creates the sub-channels that
             share one socket connection, as <a href="http://beepcore.org/">BEEP</a> and
             <a href="http://en.wikipedia.org/wiki/Secure_Shell">SSH</a> do.
            
             <h3>Downcast to access transport-specific operations</h3>
             <para>
             Some transports exposes additional operations that is specific to the
             transport.  Down-cast the <see cref="T:DotNetty.Transport.Channels.IChannel"/> to sub-type to invoke such
             operations.  For example, with the old I/O datagram transport, multicast
             join / leave operations are provided by <see cref="T:DotNetty.Transport.Channels.Sockets.IDatagramChannel"/>.
            
             <h3>Release resources</h3>
             </para>
             It is important to call <see cref="M:DotNetty.Transport.Channels.IChannel.CloseAsync"/> to release all
             resources once you are done with the <see cref="T:DotNetty.Transport.Channels.IChannel"/>. This ensures all resources are
             released in a proper way, i.e. filehandles.
             </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Id">
            <summary>
            Gets the globally unique identifier of this <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Allocator">
            <summary>
            Return the assigned <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/> which will be used to allocate <see cref="T:DotNetty.Buffers.IByteBuffer"/>s.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.EventLoop">
            <summary>
            Gets the <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> this <see cref="T:DotNetty.Transport.Channels.IChannel"/> was registered to.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Parent">
            <summary>
            Gets the parent of this channel.
            Returns <c>null</c> if this channel does not have a parent channel.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Open">
            <summary>
            Returns <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> is open and may get active later.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Active">
            <summary>
            Returns <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> is active and so connected.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Registered">
            <summary>
            Returns <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> is registered with an <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Metadata">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.ChannelMetadata"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/> which describe the nature of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.LocalAddress">
            <summary>
            Returns the local address where this channel is bound to.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.RemoteAddress">
            <summary>
            Returns the remote address where this channel is connected to.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.IsWritable">
            <summary>
            Returns <c>true</c> if and only if the I/O thread will perform the
            requested write operation immediately.Any write requests made when
            this method returns <c>false</c> are queued until the I/O thread is
            ready to process the queued write requests.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.BytesBeforeUnwritable">
            <summary>
            Get how many bytes can be written until <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/> returns <c>false</c>.
            This quantity will always be non-negative. If <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/> is <c>false</c> then 0.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.BytesBeforeWritable">
            <summary>
            Get how many bytes must be drained from underlying buffers until <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/> returns <c>true</c>.
            This quantity will always be non-negative. If <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/> is <c>true</c> then 0.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Unsafe">
            <summary>
            Returns an <em>internal-use-only</em> object that provides unsafe operations.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Pipeline">
            <summary>
            Returns the assigned <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Configuration">
            <summary>
            Returns the configuration of this channel.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannel.BindAsync(System.Net.EndPoint)">
            <summary>
            Bind the <see cref="T:System.Net.EndPoint"/> to the <see cref="T:DotNetty.Transport.Channels.IChannel"/> and notify it once its done.
            </summary>
            <param name="localAddress"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Connect the <see cref="T:DotNetty.Transport.Channels.IChannel"/> with the given remote <see cref="T:System.Net.EndPoint"/>.
            If a specific local <see cref="T:System.Net.EndPoint"/> should be used it need to be given as argument. Otherwise just
            pass <c>null</c> to it.
            
            The <see cref="T:System.Threading.Tasks.Task"/> will get notified once the connect operation was complete.
            </summary>
            <param name="remoteAddress"></param>
            <param name="localAddress"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannel.DisconnectAsync">
            <summary>
            Disconnect the <see cref="T:DotNetty.Transport.Channels.IChannel"/> and notify the <see cref="T:System.Threading.Tasks.Task"/> once the operation was complete.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelConfiguration.GetOption``1(DotNetty.Transport.Channels.ChannelOption{``0})">
            <summary>Return the value of the given <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelConfiguration.SetOption(DotNetty.Transport.Channels.ChannelOption,System.Object)">
            <summary>Sets a configuration property with the specified name and value.</summary>
            <returns><c>true</c> if and only if the property has been set</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelConfiguration.SetOption``1(DotNetty.Transport.Channels.ChannelOption{``0},``0)">
            <summary>Sets a configuration property with the specified name and value.</summary>
            <returns><c>true</c> if and only if the property has been set</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.ConnectTimeout">
            <summary>Gets or sets the connect timeout of the channel in milliseconds.  If the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> does not support connect operation, this property is not
            used at all, and therefore will be ignored.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.MaxMessagesPerRead">
            <summary>Gets or sets the maximum number of messages to read per read loop.
            If this value is greater than 1, an event loop might attempt to read multiple times to procure multiple messages.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.WriteSpinCount">
            <summary>Gets or sets the maximum loop count for a write operation until
            {@link WritableByteChannel#write(ByteBuffer)} returns a non-zero value.
            It is similar to what a spin lock is used for in concurrency programming.
            It improves memory utilization and write throughput depending on
            the platform that JVM runs on.  The default value is {@code 16}.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.Allocator">
            <summary>Gets or sets the <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/> which is used for the channel to allocate buffers.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.RecvByteBufAllocator">
            <summary>Gets or sets the <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocator"/> which is used for the channel to allocate receive buffers.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.AutoRead">
            <summary>Gets or sets if <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.Read"/> will be invoked automatically so that a user application doesn't
            need to call it at all. The default value is <c>true</c>.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.AutoClose">
            <summary>Gets or sets whether the <see cref="T:DotNetty.Transport.Channels.IChannel"/> should be closed automatically and immediately on write failure.
            The default is <c>true</c>.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.WriteBufferHighWaterMark">
            <summary>Gets or sets the high water mark of the write buffer.  If the number of bytes
            queued in the write buffer exceeds this value, <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/>
            will start to return <c>false</c>.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.WriteBufferLowWaterMark">
            <summary>Gets or sets the low water mark of the write buffer. Once the number of bytes
            queued in the write buffer exceeded the <see cref="P:DotNetty.Transport.Channels.IChannelConfiguration.WriteBufferHighWaterMark"/> and then
            dropped down below this value, <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/> will start to return
            <c>true</c> again.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelConfiguration.MessageSizeEstimator">
            <summary>Gets or sets the <see cref="T:DotNetty.Transport.Channels.IMessageSizeEstimator"/> which is used for the channel
            to detect the size of a message.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IChannelHandler">
             <summary>
             Handles an I/O event or intercepts an I/O operation, and forwards it to its next handler in
             its <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            
             <h3>Sub-types</h3>
             <para>
             <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> itself does not provide many methods, but you usually have to implement one of its subtypes:
             <ul>
             <li>{@link ChannelInboundHandler} to handle inbound I/O events, and</li>
             <li>{@link ChannelOutboundHandler} to handle outbound I/O operations.</li>
             </ul>
             </para>
             <para>
             Alternatively, the following adapter classes are provided for your convenience:
             <ul>
             <li>{@link ChannelInboundHandlerAdapter} to handle inbound I/O events,</li>
             <li>{@link ChannelOutboundHandlerAdapter} to handle outbound I/O operations, and</li>
             <li><see cref="T:DotNetty.Transport.Channels.ChannelDuplexHandler"/> to handle both inbound and outbound events</li>
             </ul>
             </para>
             <para>
             For more information, please refer to the documentation of each subtype.
             </para>
            
             <h3>The context object</h3>
             <para>
             A <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> is provided with a <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>
             object.  A <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> is supposed to interact with the
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> it belongs to via a context object.  Using the
             context object, the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> can pass events upstream or
             downstream, modify the pipeline dynamically, or store the information
             (using {@link AttributeKey}s) which is specific to the handler.
            
             <h3>State management</h3>
            
             A <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> often needs to store some stateful information.
             The simplest and recommended approach is to use member variables:
             </para>
             <code>
             public interface Message {
                 // your methods here
             }
            
             public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {
            
                 <b>private boolean loggedIn;</b>
            
                 {@code @Override}
                 public void channelRead0(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx, Message message) {
                     if (message instanceof LoginMessage) {
                         authenticate((LoginMessage) message);
                         <b>loggedIn = true;</b>
                     } else (message instanceof GetDataMessage) {
                         if (<b>loggedIn</b>) {
                             ctx.writeAndFlush(fetchSecret((GetDataMessage) message));
                         } else {
                             fail();
                         }
                     }
                 }
                 ...
             }
             </code>
             Because the handler instance has a state variable which is dedicated to
             one connection, you have to create a new handler instance for each new
             channel to avoid a race condition where a unauthenticated client can get
             the confidential information:
             <code>
             // Create a new handler instance per channel.
             // See {@link ChannelInitializer#initChannel(Channel)}.
             public class DataServerInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {
                 {@code @Override}
                 public void initChannel({@link Channel} channel) {
                     channel.pipeline().addLast("handler", <b>new DataServerHandler()</b>);
                 }
             }
            
             </code>
            
             <h4>Using {@link AttributeKey}s</h4>
            
             Although it's recommended to use member variables to store the state of a
             handler, for some reason you might not want to create many handler instances.
             In such a case, you can use {@link AttributeKey}s which is provided by
             <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>:
             <code>
             public interface Message {
                 // your methods here
             }
            
             {@code @Sharable}
             public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {
                 private final {@link AttributeKey}&lt;{@link Boolean}&gt; auth =
                       {@link AttributeKey#valueOf(String) AttributeKey.valueOf("auth")};
            
                 {@code @Override}
                 public void channelRead(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx, Message message) {
                     {@link Attribute}&lt;{@link Boolean}&gt; attr = ctx.attr(auth);
                     if (message instanceof LoginMessage) {
                         authenticate((LoginMessage) o);
                         <b>attr.set(true)</b>;
                     } else (message instanceof GetDataMessage) {
                         if (<b>Boolean.TRUE.equals(attr.get())</b>) {
                             ctx.writeAndFlush(fetchSecret((GetDataMessage) o));
                         } else {
                             fail();
                         }
                     }
                 }
                 ...
             }
             </code>
             Now that the state of the handler is attached to the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>, you can add the
             same handler instance to different pipelines:
             <code>
             public class DataServerInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {
            
                 private static final DataServerHandler <b>SHARED</b> = new DataServerHandler();
            
                 {@code @Override}
                 public void initChannel({@link Channel} channel) {
                     channel.pipeline().addLast("handler", <b>SHARED</b>);
                 }
             }
             </code>
            
            
             <h3>Additional resources worth reading</h3>
             <para>
             Please refer to the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>, and
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> to find out more about inbound and outbound operations,
             what fundamental differences they have, how they flow in a  pipeline,  and how to handle
             the operation in your application.
             </para>
             </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRegistered(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            The <see cref="T:DotNetty.Transport.Channels.IChannel"/> of the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> was registered with its
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ChannelUnregistered(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            The <see cref="T:DotNetty.Transport.Channels.IChannel"/> of the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> was unregistered from its
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ChannelWritabilityChanged(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Gets called once the writable state of a <see cref="T:DotNetty.Transport.Channels.IChannel"/> changed. You can check the state with
            <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Gets called after the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> was added to the actual context and it's ready to handle events.
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Gets called after the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> was removed from the actual context and it doesn't handle events
            anymore.
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.BindAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)">
            <summary>
            Called once a bind operation is made.
            </summary>
            <param name="context">
            The <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> for which the bind operation is made.
            </param>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to which it should bind.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Called once a connect operation is made.
            </summary>
            <param name="context">
            The <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> for which the connect operation is made.
            </param>
            <param name="remoteAddress">The <see cref="T:System.Net.EndPoint"/> to which it should connect.</param>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> which is used as source on connect.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.Disconnect(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Called once a disconnect operation is made.
            </summary>
            <param name="context">
            The <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> for which the disconnect operation is made.
            </param>
            <param name="promise"></param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)">
            <summary>
            Gets called if a <see cref="T:System.Exception"/> was thrown.
            </summary>
            <param name="context"></param>
            <param name="exception"></param>
        </member>
        <member name="T:DotNetty.Transport.Channels.IChannelHandlerContext">
             <summary>
             Enables a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to interact with its <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>
             and other handlers. Among other things a handler can notify the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in the
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> as well as modify the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> it belongs to dynamically.
            
             <h3>Notify</h3>
            
             You can notify the closest handler in the same <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> by calling one of the various methods
             provided here.
            
             Please refer to <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> to understand how an event flows.
            
             <h3>Modifying a pipeline</h3>
            
             You can get the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> your handler belongs to by calling
             <see cref="P:DotNetty.Transport.Channels.IChannelHandlerContext.Pipeline"/>.  A non-trivial application could insert, remove, or
             replace handlers in the pipeline dynamically at runtime.
            
             <h3>Retrieving for later use</h3>
            
             You can keep the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> for later use, such as
             triggering an event outside the handler methods, even from a different thread.
             <code>
             public class MyHandler extends <see cref="T:DotNetty.Transport.Channels.ChannelDuplexHandler"/> {
            
                 <b>private <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx;</b>
            
                 public void beforeAdd(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx) {
                     <b>this.ctx = ctx;</b>
                 }
            
                 public void login(String username, password) {
                     ctx.write(new LoginMessage(username, password));
                 }
                 ...
             }
             </code>
            
             <h3>Storing stateful information</h3>
            
             <see cref="M:DotNetty.Common.Utilities.IAttributeMap.GetAttribute``1(DotNetty.Common.Utilities.AttributeKey{``0})"/> allow you to
             store and access stateful information that is related with a handler and its
             context.  Please refer to <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to learn various recommended
             ways to manage stateful information.
            
             <h3>A handler can have more than one context</h3>
            
             Please note that a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> instance can be added to more than
             one <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.  It means a single <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>
             instance can have more than one <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> and therefore
             the single instance can be invoked with different
             <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>s if it is added to one or more
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>s more than once.
             <para>
             For example, the following handler will have as many independent <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/>s
             as how many times it is added to pipelines, regardless if it is added to the
             same pipeline multiple times or added to different pipelines multiple times:
             </para>
             <code>
             public class FactorialHandler extends {@link ChannelInboundHandlerAdapter} {
            
               private final <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/>&lt;{@link Integer}&gt; counter = <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/>.valueOf("counter");
            
               // This handler will receive a sequence of increasing integers starting
               // from 1.
               {@code @Override}
               public void channelRead({@link ChannelHandlerContext} ctx, Object msg) {
                 Integer a = ctx.attr(counter).get();
            
                 if (a == null) {
                   a = 1;
                 }
            
                 attr.set(a /// (Integer) msg);
               }
             }
            
             // Different context objects are given to "f1", "f2", "f3", and "f4" even if
             // they refer to the same handler instance.  Because the FactorialHandler
             // stores its state in a context object (using an <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/>), the factorial is
             // calculated correctly 4 times once the two pipelines (p1 and p2) are active.
             FactorialHandler fh = new FactorialHandler();
            
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> p1 = {@link Channels}.pipeline();
             p1.addLast("f1", fh);
             p1.addLast("f2", fh);
            
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> p2 = {@link Channels}.pipeline();
             p2.addLast("f3", fh);
             p2.addLast("f4", fh);
             </code>
            
             <h3>Additional resources worth reading</h3>
             <para>
             Please refer to the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>, and
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> to find out more about inbound and outbound operations,
             what fundamental differences they have, how they flow in a  pipeline,  and how to handle
             the operation in your application.
             </para>
             </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Channel">
            <summary>
            Return the <see cref="T:DotNetty.Transport.Channels.IChannel"/> which is bound to the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Allocator">
            <summary>
            Return the assigned <see cref="T:DotNetty.Buffers.IByteBufferAllocator"/> which will be used to allocate <see cref="T:DotNetty.Buffers.IByteBuffer"/>s.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Executor">
            <summary>
            Returns the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> which is used to execute an arbitrary task.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Name">
            <summary>
            The unique name of the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.
            </summary>
            <remarks>
            The name was used when the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> was added to the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            This name can also be used to access the registered <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> from the
            <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </remarks>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Handler">
            <summary>
            The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> that is bound this <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Removed">
            <summary>
            Return <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> which belongs to this context was removed
            from the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>. Note that this method is only meant to be called from with in the
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRegistered">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> was registered to its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>. This will result in having the
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRegistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>
            contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>The current <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelUnregistered">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> was unregistered from its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>. This will result in having the
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelUnregistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>
            contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>The current <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Pipeline">
            <summary>
             Return the assigned <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.BindAsync(System.Net.EndPoint)">
            <summary>
            Request to bind to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.BindAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to bind to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/> while also binding to the localAddress.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to bind to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.DisconnectAsync">
            <summary>
            Request to disconnect from the remote peer.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.Disconnect(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.DeregisterAsync">
            <summary>
            Request to deregister from the previous assigned <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.Deregister(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelId.AsShortText">
            <summary>
            Returns the short but globally non-unique string representation of the <see cref="T:DotNetty.Transport.Channels.IChannelId"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelId.AsLongText">
            <summary>
            Returns the long yet globally unique string representation of the <see cref="T:DotNetty.Transport.Channels.IChannelId"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IChannelPipeline">
            <summary>
            A list of <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s which handles or intercepts inbound events and outbound operations of
            a <see cref="T:DotNetty.Transport.Channels.IChannel"/>. <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> implements an advanced form of the
            <a href="http://www.oracle.com/technetwork/java/interceptingfilter-142169.html">Intercepting Filter</a> pattern
            to give a user full control over how an event is handled and how the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in a
            pipeline interact with each other.
            <para>Creation of a pipeline</para>
            <para>Each channel has its own pipeline and it is created automatically when a new channel is created.</para>
            <para>How an event flows in a pipeline</para>
            <para>
            The following diagram describes how I/O events are processed by <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in a
            <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> typically. An I/O event is handled by a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> and is
            forwarded by the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> which handled the event to the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>
            which is placed right next to it. A <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> can also trigger an arbitrary I/O event if
            necessary. To forward or trigger an event, a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> calls the event propagation methods
            defined in <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>, such as <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRead(System.Object)"/>
            and <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object,DotNetty.Common.Concurrency.IPromise)"/>.
            </para>
            <para>
                <pre>
                    I/O Request
                    via <see cref="T:DotNetty.Transport.Channels.IChannel"/> or
                    <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> 
                    |
                    +---------------------------------------------------+---------------+
                    |                           ChannelPipeline         |               |
                    |                                                  \|/              |
                    |    +----------------------------------------------+----------+    |
                    |    |                   ChannelHandler  N                     |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  |               |
                    |               |                                  \|/              |
                    |    +----------+-----------------------------------+----------+    |
                    |    |                   ChannelHandler N-1                    |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  .               |
                    |               .                                   .               |
                    | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
                    |          [method call]                      [method call]         |
                    |               .                                   .               |
                    |               .                                  \|/              |
                    |    +----------+-----------------------------------+----------+    |
                    |    |                   ChannelHandler  2                     |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  |               |
                    |               |                                  \|/              |
                    |    +----------+-----------------------------------+----------+    |
                    |    |                   ChannelHandler  1                     |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  |               |
                    +---------------+-----------------------------------+---------------+
                    |                                  \|/
                    +---------------+-----------------------------------+---------------+
                    |               |                                   |               |
                    |       [ Socket.read() ]                    [ Socket.write() ]     |
                    |                                                                   |
                    |  Netty Internal I/O Threads (Transport Implementation)            |
                    +-------------------------------------------------------------------+
                </pre>
            </para>
            <para>
            An inbound event is handled by the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in the bottom-up direction as shown on the
            left side of the diagram. An inbound event is usually triggered by the I/O thread on the bottom of the diagram
            so that the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s are notified when the state of a <see cref="T:DotNetty.Transport.Channels.IChannel"/> changes
            (e.g. newly established connections and closed connections) or the inbound data was read from a remote peer. If
            an inbound event goes beyond the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the top of the diagram, it is discarded and
            logged, depending on your loglevel.
            </para>
            <para>
            An outbound event is handled by the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in the top-down direction as shown on the
            right side of the diagram. An outbound event is usually triggered by your code that requests an outbound I/O
            operation, such as a write request and a connection attempt.  If an outbound event goes beyond the
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the bottom of the diagram, it is handled by an I/O thread associated with the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>. The I/O thread often performs the actual output operation such as
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel`2.WriteAsync(System.Object,DotNetty.Common.Concurrency.IPromise)"/>.
            </para>
            <para>Forwarding an event to the next handler</para>
            <para>
            As explained briefly above, a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> has to invoke the event propagation methods in
            <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> to forward an event to its next handler. Those methods include:
                <ul>
                    <li>
                        Inbound event propagation methods:
                        <ul>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRegistered"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelActive"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRead(System.Object)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelReadComplete"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireExceptionCaught(System.Exception)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireUserEventTriggered(System.Object)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelWritabilityChanged"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelInactive"/></li>
                        </ul>
                    </li>
                    <li>
                        Outbound event propagation methods:
                        <ul>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.BindAsync(System.Net.EndPoint)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object,DotNetty.Common.Concurrency.IPromise)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.Flush"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.Read"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.DisconnectAsync(DotNetty.Common.Concurrency.IPromise)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.CloseAsync(DotNetty.Common.Concurrency.IPromise)"/></li>
                        </ul>
                    </li>
                </ul>
            </para>
            <para>
                and the following example shows how the event propagation is usually done:
                <code>
                    public class MyInboundHandler : <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/>
                    {
                        public override void ChannelActive(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx)
                        {
                            Console.WriteLine("Connected!");
                            ctx.FireChannelActive();
                        }
                    }
            
                    public class MyOutboundHandler : <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/>
                    {
                        public override async Task CloseAsync(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx)
                        {
                            Console.WriteLine("Closing...");
                            await ctx.CloseAsync();
                        }
                    }
                </code>
            </para>
            <para>Building a pipeline</para>
            <para>
            A user is supposed to have one or more <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in a pipeline to receive I/O events
            (e.g. read) and to request I/O operations (e.g. write and close).  For example, a typical server will have the
            following handlers in each channel's pipeline, but your mileage may vary depending on the complexity and
            characteristics of the protocol and business logic:
                <ol>
                    <li>Protocol Decoder - translates binary data (e.g. <see cref="T:DotNetty.Buffers.IByteBuffer"/>) into a Java object.</li>
                    <li>Protocol Encoder - translates a Java object into binary data.</li>
                    <li>Business Logic Handler - performs the actual business logic (e.g. database access).</li>
                </ol>
            </para>
            <para>
                and it could be represented as shown in the following example:
                <code>
                    static readonly <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> group = new <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>();
                    ...
                    <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> pipeline = ch.Pipeline;
                    pipeline.AddLast("decoder", new MyProtocolDecoder());
                    pipeline.AddLast("encoder", new MyProtocolEncoder());
            
                    // Tell the pipeline to run MyBusinessLogicHandler's event handler methods
                    // in a different thread than an I/O thread so that the I/O thread is not blocked by
                    // a time-consuming task.
                    // If your business logic is fully asynchronous or finished very quickly, you don't
                    // need to specify a group.
                    pipeline.AddLast(group, "handler", new MyBusinessLogicHandler());
                </code>
            </para>
            <para>Thread safety</para>
            <para>
            An <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> can be added or removed at any time because an <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>
            is thread safe. For example, you can insert an encryption handler when sensitive information is about to be
            exchanged, and remove it after the exchange.
            </para>
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts an <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the first position of this pipeline.
            </summary>
            <param name="name">
            The name of the handler to insert first. Pass <c>null</c> to let the name auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to insert first.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the first position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="name">
            The name of the handler to insert first. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to insert first.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Appends an <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the last position of this pipeline.
            </summary>
            <param name="name">
            The name of the handler to append. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Appends a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the last position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="name">
            The name of the handler to append. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddBefore(System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> before an existing handler of this pipeline.
            </summary>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddBefore(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> before an existing handler of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddAfter(System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> after an existing handler of this pipeline.
            </summary>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The handler to insert after.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddAfter(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> after an existing handler of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The handler to insert after.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the first position of this pipeline.
            </summary>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the first position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handlers"/>' event handler methods.
            </param>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the last position of this pipeline.
            </summary>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the last position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handlers"/>' event handler methods.
            </param>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Remove(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Removes the specified <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> from this pipeline.
            </summary>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to remove.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the specified handler was not found.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Remove(System.String)">
            <summary>
            Removes the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with the specified name from this pipeline.
            </summary>
            <param name="name">The name under which the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> was stored.</param>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if there's no such handler with the specified name in this pipeline.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Remove``1">
            <summary>
            Removes the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type from this pipeline.
            </summary>
            <typeparam name="T">The type of handler to remove.</typeparam>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if there's no handler of the specified type in this pipeline.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.RemoveFirst">
            <summary>
            Removes the first <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this pipeline is empty.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.RemoveLast">
            <summary>
            Removes the last <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this pipeline is empty.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Replace(DotNetty.Transport.Channels.IChannelHandler,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Replaces the specified <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with a new handler in this pipeline.
            </summary>
            <param name="oldHandler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be replaced.</param>
            <param name="newName">
            The name of the new handler being inserted. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="newHandler">The new <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be inserted.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="newName"/> already exists, or if the
            <paramref name="oldHandler"/> was not found.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Replace(System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Replaces the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified name with a new handler in this pipeline.
            </summary>
            <param name="oldName">The name of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be replaced.</param>
            <param name="newName">
            The name of the new handler being inserted. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="newHandler">The new <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be inserted.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> that was replaced.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="newName"/> already exists, or if no match was found for
            the given <paramref name="oldName"/>.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Replace``1(System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Replaces the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type with a new handler in this pipeline.
            </summary>
            <typeparam name="T">The type of the handler to be removed.</typeparam>
            <param name="newName">
            The name of the new handler being inserted. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="newHandler">The new <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be inserted.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> that was replaced.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="newName"/> already exists, or if no match was found for
            the given type.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.First">
            <summary>
            Returns the first <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The first handler in the pipeline, or <c>null</c> if the pipeline is empty.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FirstContext">
            <summary>
            Returns the context of the first <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>
            The context of the first handler in the pipeline, or <c>null</c> if the pipeline is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Last">
            <summary>
            Returns the last <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The last handler in the pipeline, or <c>null</c> if the pipeline is empty.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.LastContext">
            <summary>
            Returns the context of the last <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>
            The context of the last handler in the pipeline, or <c>null</c> if the pipeline is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Get(System.String)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with the specified name in this pipeline.
            </summary>
            <param name="name">The name of the desired <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</param>
            <returns>
            The handler with the specified name, or <c>null</c> if there's no such handler in this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Get``1">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type in this pipeline.
            </summary>
            <typeparam name="T">The type of handler to retrieve.</typeparam>
            <returns>
            The handler with the specified type, or <c>null</c> if there's no such handler in this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Context(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Returns the context object of the specified <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> whose context should be retrieved.</param>
            <returns>
            The context object of the specified handler, or <c>null</c> if there's no such handler in this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Context(System.String)">
            <summary>
            Returns the context object of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with the specified name in this pipeline.
            </summary>
            <param name="name">The name of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> whose context should be retrieved.</param>
            <returns>
            The context object of the handler with the specified name, or <c>null</c> if there's no such handler in
            this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Context``1">
            <summary>
            Returns the context object of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type in this pipeline.
            </summary>
            <typeparam name="T">The type of <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> whose context should be retrieved.</typeparam>
            <returns>
            The context object of the handler with the specified type, or <c>null</c> if there's no such handler in
            this pipeline.
            </returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelPipeline.Channel">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.IChannel" /> that this pipeline is attached to.
            Returns <c>null</c> if this pipeline is not attached to any channel yet.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelRegistered">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> was registered to its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRegistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelUnregistered">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> was unregistered from its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelUnregistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelActive">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> is active now, which means it is connected.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelActive(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelInactive">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> is inactive now, which means it is closed.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireExceptionCaught(System.Exception)">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> received an <see cref="T:System.Exception"/> in one of its inbound operations.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> that was caught.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireUserEventTriggered(System.Object)">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> received an user defined event.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="evt">The user-defined event that was triggered.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelRead(System.Object)">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> received a message.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="msg">The message that was received.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelReadComplete">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> completed a message after reading it.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelWritabilityChanged">
            <summary>
            Triggers an <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelWritabilityChanged(DotNetty.Transport.Channels.IChannelHandlerContext)"/> event to the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.BindAsync(System.Net.EndPoint)">
            <summary>
            Request to bind to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.BindAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.ConnectAsync(System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The local <see cref="T:System.Net.EndPoint"/> to bind.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.DisconnectAsync">
            <summary>
            Request to disconnect from the remote peer.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.Disconnect(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.CloseAsync">
            <summary>
            Request to close the <see cref="T:DotNetty.Transport.Channels.IChannel"/>. After it is closed it is not possible to reuse it again.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.Close(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.DeregisterAsync">
            <summary>
            Request to deregister the <see cref="T:DotNetty.Transport.Channels.IChannel"/> bound this <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> from the
            previous assigned <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.Deregister(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Common.Concurrency.IPromise)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Read">
            <summary>
            Request to Read data from the <see cref="T:DotNetty.Transport.Channels.IChannel"/> into the first inbound buffer, triggers an
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> event if data was read, and triggers a
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)"/> event so the handler can decide whether to continue
            reading. If there's a pending read operation already, this method does nothing.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.Read(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.WriteAsync(System.Object)">
            <summary>
            Request to write a message via this <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            This method will not request to actual flush, so be sure to call <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.Flush"/>
            once you want to request to flush all pending data to the actual transport.
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Flush">
            <summary>
            Request to flush all pending messages.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.WriteAndFlushAsync(System.Object)">
            <summary>
            Shortcut for calling both <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.WriteAsync(System.Object)"/> and <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.Flush"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelUnsafe.RecvBufAllocHandle">
            <summary>
            Gets the assigned <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle"/> which will be used to allocate <see cref="T:DotNetty.Buffers.IByteBuffer"/>'s when
            receiving data.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelUnsafe.RegisterAsync(DotNetty.Transport.Channels.IEventLoop)">
            <summary>
            Register the <see cref="T:DotNetty.Transport.Channels.IChannel"/> and notify
            the <see cref="T:System.Threading.Tasks.Task"/> once the registration was complete.
            </summary>
            <param name="eventLoop"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.IEventLoop">
            <summary>
            <see cref="T:DotNetty.Common.Concurrency.IOrderedEventExecutor"/> specialized to handle I/O operations of assigned <see cref="T:DotNetty.Transport.Channels.IChannel"/>s.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IEventLoop.Parent">
            <summary>
            Parent <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IEventLoopGroup">
            <inheritdoc />
            <summary>
            <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup" /> specialized for handling <see cref="T:DotNetty.Transport.Channels.IEventLoop" />s.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IEventLoopGroup.Items">
            <summary>
            Returns list of owned event loops.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IEventLoopGroup.GetNext">
            <summary>
            Returns one of owned event loops.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IEventLoopGroup.RegisterAsync(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Register the <see cref="T:DotNetty.Transport.Channels.IChannel"/> for this event loop.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> to register.</param>
            <returns>The register task.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.IFileRegion.Position">
            <summary>Returns the offset in the file where the transfer began.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IFileRegion.Transferred">
            <summary>Returns the bytes which was transferred already.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IFileRegion.Count">
            <summary>Returns the number of bytes to transfer.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IFileRegion.TransferTo(System.IO.Stream,System.Int64)">
            <summary>Transfers the content of this file region to the specified channel.</summary>
            <param name="target">the destination of the transfer</param>
            <param name="position">the relative offset of the file where the transfer
            begins from.  For example, <tt>0</tt> will make the
            transfer start from <see cref="P:DotNetty.Transport.Channels.IFileRegion.Position"/>th byte and
            <tt><see cref="P:DotNetty.Transport.Channels.IFileRegion.Count"/> - 1</tt> will make the last
            byte of the region transferred.</param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator">
            <summary>
                <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocator" /> that limits the number of read operations that will be attempted when a read
                operation
                is attempted by the event loop.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator.MaxMessagesPerRead">
            <summary>
                Gets or sets the maximum number of messages to read per read loop.
                If this value is greater than 1, an event loop might attempt to read multiple times to procure multiple messages.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IMessageSizeEstimator">
            <summary>
            Responsible to estimate the size of a message. The size represents approximately how much memory the message will
            reserve in memory.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IMessageSizeEstimator.NewHandle">
            <summary>
            Creates a new handle. The handle provides the actual operations.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IMessageSizeEstimatorHandle.Size(System.Object)">
            <summary>
            Calculates the size of the given message.
            </summary>
            <param name="msg">The message for which the size should be calculated.</param>
            <returns>The size in bytes. The returned size must be >= 0</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.IRecvByteBufAllocator">
            <summary>
                Allocates a new receive buffer whose capacity is probably large enough to read all inbound data and small enough
                not to waste its space.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocator.NewHandle">
            <summary>
                Creates a new handle.  The handle provides the actual operations and keeps the internal information which is
                required for predicting an optimal buffer capacity.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Allocate(DotNetty.Buffers.IByteBufferAllocator)">
            <summary>
                Creates a new receive buffer whose capacity is probably large enough to read all inbound data and small
                enough not to waste its space.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Guess">
            <summary>
                Similar to <see cref="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Allocate(DotNetty.Buffers.IByteBufferAllocator)" /> except that it does not allocate anything but just tells the
                capacity.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Reset(DotNetty.Transport.Channels.IChannelConfiguration)">
            <summary>
                Reset any counters that have accumulated and recommend how many messages/bytes should be read for the next
                read loop.
                <p>
                    This may be used by <see cref="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ContinueReading" /> to determine if the read operation should complete.
                </p>
                This is only ever a hint and may be ignored by the implementation.
            </summary>
            <param name="config">The channel configuration which may impact this object's behavior.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.IncMessagesRead(System.Int32)">
            <summary>Increment the number of messages that have been read for the current read loop.</summary>
            <param name="numMessages">The amount to increment by.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.LastBytesRead">
            <summary>
                Get or set the bytes that have been read for the last read operation.
                This may be used to increment the number of bytes that have been read.
            </summary>
            <remarks>
                Returned value may be negative if an read error
                occurs. If a negative value is seen it is expected to be return on the next set to
                <see cref="P:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.LastBytesRead" />. A negative value will signal a termination condition enforced externally
                to this class and is not required to be enforced in <see cref="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ContinueReading" />.
            </remarks>
        </member>
        <member name="P:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.AttemptedBytesRead">
            <summary>Get or set how many bytes the read operation will (or did) attempt to read.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ContinueReading">
            <summary>Determine if the current read loop should continue.</summary>
            <returns><c>true</c> if the read loop should continue reading. <c>false</c> if the read loop is complete.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ReadComplete">
            <summary>Signals read completion.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IServerChannel">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> that accepts an incoming connection attempt and creates its child
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>s by accepting them. <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel"/> is a good example.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Local.LocalChannel">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> for the local transport.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Local.LocalServerChannel">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IServerChannel"/> for the local transport which allows in VM communication.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Local.LocalServerChannel.NewLocalChannel(DotNetty.Transport.Channels.Local.LocalChannel)">
            <summary>
            A factory method for <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/>s. Users may override it to create custom instances of <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/>s.
            </summary>
            <param name="peer">An existing <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/> that will act as a peer for the new channel.</param>
            <returns>The newly created <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/> instance.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> backed by a set of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/> instances.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.MultithreadEventLoopGroup.TerminationCompletion">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.GetItems">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Transport.Channels.MultithreadEventLoopGroup.Items">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor(System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor(System.Func{DotNetty.Transport.Channels.IEventLoopGroup,DotNetty.Transport.Channels.IEventLoop})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor(System.Func{DotNetty.Transport.Channels.IEventLoopGroup,DotNetty.Transport.Channels.IEventLoop},System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.DotNetty#Transport#Channels#IEventLoopGroup#GetNext">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.GetNext">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync" />
        </member>
        <member name="T:DotNetty.Transport.Channels.PendingWriteQueue">
            <summary>
            A queue of write operations which are pending for later execution. It also updates the writability of the
            associated <see cref="T:DotNetty.Transport.Channels.IChannel"/> (<see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/>), so that the pending write operations are
            also considered to determine the writability.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.PendingWriteQueue.IsEmpty">
            <summary>
            Returns <c>true</c> if there are no pending write operations left in this queue.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.PendingWriteQueue.Size">
            <summary>
            Returns the number of pending write operations.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.PendingWriteQueue.Bytes">
            <summary>
            Returns the total number of bytes that are pending because of pending messages. This is only an estimate so
            it should only be treated as a hint.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.Add(System.Object,DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Adds the given message to this <see cref="T:DotNetty.Transport.Channels.PendingWriteQueue"/>.
            </summary>
            <param name="msg">The message to add to the <see cref="T:DotNetty.Transport.Channels.PendingWriteQueue"/>.</param>
            <param name="promise"></param>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndFailAll(System.Exception)">
            <summary>
            Removes all pending write operations, and fail them with the given <see cref="T:System.Exception"/>. The messages
            will be released via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> to fail with.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndFail(System.Exception)">
            <summary>
            Remove a pending write operation and fail it with the given <see cref="T:System.Exception"/>. The message will be
            released via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> to fail with.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndWriteAllAsync">
            <summary>
            Removes all pending write operation and performs them via <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object,DotNetty.Common.Concurrency.IPromise)"/>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndWriteAsync">
            <summary>
            Removes a pending write operation and performs it via <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object,DotNetty.Common.Concurrency.IPromise)"/>.
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.Remove">
            <summary>
            Removes a pending write operation and releases it's message via
            <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <returns>
            The <see cref="T:DotNetty.Common.Concurrency.IPromise" /> of the pending write, or <c>null</c> if the queue is empty.
            </returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.PendingWriteQueue.Current">
            <summary>
            Return the current message, or <c>null</c> if the queue is empty.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.PendingWriteQueue.PendingWrite">
            <summary>
            Holds all meta-data and constructs the linked-list structure.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.AbstractChannelPoolHandler">
            <summary>
            A skeletal <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolHandler.ChannelAcquired(DotNetty.Transport.Channels.IChannel)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolHandler.ChannelReleased(DotNetty.Transport.Channels.IChannel)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolHandler.ChannelCreated(DotNetty.Transport.Channels.IChannel)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.Remove(`0)">
            <summary>
            Removes the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> from this <see cref="T:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2"/>.
            
            <para>If the removed pool extends <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> it will be closed asynchronously to avoid blocking in
            this method.</para>
            </summary>
            <param name="key">The key to remove. Must not be null.</param>
            <returns><c>true</c> if removed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.PoolCloseAsyncIfSupported(DotNetty.Transport.Channels.Pool.IChannelPool)">
            <summary>
            If the pool implementation supports asynchronous close, then use it to avoid a blocking close call in case
            the ChannelPoolMap operations are called from an EventLoop.
            </summary>
            <param name="pool">the ChannelPool to be closed</param>
            <returns></returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.Count">
            <summary>
            Returns the number of <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>s currently in this <see cref="T:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.IsEmpty">
            <summary>
            Returns <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2"/> is empty, otherwise <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.NewPool(`0)">
            <summary>
            Called once a new <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> needs to be created as none exists yet for the <paramref name="key"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> to create a new <typeparamref name="TPool"/> for.</param>
            <returns>The new <typeparamref name="TPool"/> corresponding to the given <typeparamref name="TKey"/>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.ChannelActiveHealthChecker">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> implementation that checks if <see cref="P:DotNetty.Transport.Channels.IChannel.Active"/> returns <c>true</c>.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.FixedChannelPool">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementation that takes another <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementation and
            enforces a maximum number of concurrent connections.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction.New">
            <summary>
            Creates a new connection when the timeout is detected.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction.Fail">
            <summary>
            Fails the <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> of the acquire call with a <see cref="T:System.TimeoutException"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance using the <see cref="T:DotNetty.Transport.Channels.Pool.ChannelActiveHealthChecker"/>.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction,System.TimeSpan,System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="action">
            The <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> to use or <c>null</c> if none should be used. In this case,
            <paramref name="acquireTimeout"/> must also be <c>null</c>.
            </param>
            <param name="acquireTimeout">
            A <see cref="T:System.TimeSpan"/> after which an pending acquire must complete, or the
            <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> takes place.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction,System.TimeSpan,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="action">
            The <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> to use or <c>null</c> if none should be used. In this case,
            <paramref name="acquireTimeout"/> must also be <c>null</c>.
            </param>
            <param name="acquireTimeout">
            A <see cref="T:System.TimeSpan"/> after which an pending acquire must complete, or the
            <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> takes place.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
            <param name="releaseHealthCheck">If <c>true</c>, will check channel health before offering it back.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction,System.TimeSpan,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="action">
            The <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> to use or <c>null</c> if none should be used. In this case,
            <paramref name="acquireTimeout"/> must also be <c>null</c>.
            </param>
            <param name="acquireTimeout">
            A <see cref="T:System.TimeSpan"/> after which an pending acquire must complete, or the
            <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> takes place.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
            <param name="releaseHealthCheck">If <c>true</c>, will check channel health before offering it back.</param>
            <param name="lastRecentUsed">
            If <c>true</c>, <see cref="T:DotNetty.Transport.Channels.IChannel"/> selection will be LIFO. If <c>false</c>, it will be FIFO.
            </param>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquiredChannelCount">
            <summary>Returns the number of acquired channels that this pool thinks it has.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker">
            <summary>
            Called before an <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be returned via <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.AcquireAsync"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelHealthChecker.IsHealthyAsync(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Checks if the given channel is healthy (which means it can be used). This method will be called by the
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> of the given <see cref="T:DotNetty.Transport.Channels.IChannel"/>
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> to check for healthiness.</param>
            <returns><c>true</c> if the given <see cref="T:DotNetty.Transport.Channels.IChannel"/> is healthy, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelPool">
            <summary>
            Allows the acquisition and release of <see cref="T:DotNetty.Transport.Channels.IChannel"/> instances, and so act as a pool of these.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPool.AcquireAsync">
            <summary>
            Acquires an <see cref="T:DotNetty.Transport.Channels.IChannel"/> from this <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            <para>
            It is important that an acquired <see cref="T:DotNetty.Transport.Channels.IChannel"/> is always released to the pool again via the
            <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.ReleaseAsync(DotNetty.Transport.Channels.IChannel)"/> method, even if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> is explicitly closed.
            </para>
            </summary>
            <returns>The aquired <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPool.ReleaseAsync(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Releases a previously aquired <see cref="T:DotNetty.Transport.Channels.IChannel"/> from this <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>, allowing it to
            be aquired again by another caller.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance to be released.</param>
            <returns>
            <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was successfully released, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler">
            <summary>
            Handler which is called for various actions done by the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolHandler.ChannelReleased(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Called once a <see cref="T:DotNetty.Transport.Channels.IChannel"/> was released by calling <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.ReleaseAsync(DotNetty.Transport.Channels.IChannel)"/>.
            This method will be called by the <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance which was released.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolHandler.ChannelAcquired(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Called once a <see cref="T:DotNetty.Transport.Channels.IChannel"/> was acquired by calling <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.AcquireAsync"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance which was aquired.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolHandler.ChannelCreated(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Called once a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> is created in the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance which was aquired.</param>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2">
            <summary>
            Allows the mapping of <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementations to a specific key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TPool">The type of the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.</typeparam>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2.Get(`0)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> for the <paramref name="key"/>. This will never return <c>null</c>,
            but create a new <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> if non exists for they requested <paramref name="key"/>.
            Please note that <c>null</c> keys are not allowed.
            </summary>
            <param name="key">The key for the desired <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/></param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> for the specified <paramref name="key"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2.Contains(`0)">
            <summary>
            Checks whether the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2"/> contains an <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> for the
            given <paramref name="key"/>. Please note that <c>null</c> keys are not allowed.
            </summary>
            <param name="key">The key to search the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2"/> for.</param>
            <returns><c>true</c> if a <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> exists for the given <paramref name="key"/>, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool">
            <summary>
            Simple <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementation which will create new <see cref="T:DotNetty.Transport.Channels.IChannel"/>s if someone tries to acquire
            a <see cref="T:DotNetty.Transport.Channels.IChannel"/> but none is in the pool atm. No limit on the maximal concurrent <see cref="T:DotNetty.Transport.Channels.IChannel"/>s is enforced.
            This implementation uses LIFO order for <see cref="T:DotNetty.Transport.Channels.IChannel"/>s in the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance using the <see cref="T:DotNetty.Transport.Channels.Pool.ChannelActiveHealthChecker"/>.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="releaseHealthCheck">
            If <c>true</c>, will check channel health before offering back. Otherwise, channel health is only checked
            at acquisition time.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The<see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="releaseHealthCheck">
            If <c>true</c>, will check channel health before offering back. Otherwise, channel health is only checked
            at acquisition time.
            </param>
            <param name="lastRecentUsed">
            If <c>true</c>, <see cref="T:DotNetty.Transport.Channels.IChannel"/> selection will be LIFO. If <c>false</c>, it will be FIFO.
            </param>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.Bootstrap">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> this pool will use to open new connections. 
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.Handler">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.HealthChecker">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if an <see cref="T:DotNetty.Transport.Channels.IChannel"/> is healthy.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.ReleaseHealthCheck">
            <summary>
            Indicates whether this pool will check the health of channels before offering them back into the pool.
            Returns <c>true</c> if this pool will check the health of channels before offering them back into the pool, or
            <c>false</c> if channel health is only checked at acquisition time.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.ConnectChannel(DotNetty.Transport.Bootstrapping.Bootstrap)">
            <summary>
            Bootstrap a new <see cref="T:DotNetty.Transport.Channels.IChannel"/>. The default implementation uses
            <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/>, sub-classes may override this.
            </summary>
            <param name="bs">
            The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance to use to bootstrap a new <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> passed here is cloned via
            <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.Clone"/>, so it is safe to modify.
            </param>
            <returns>The newly connected <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.DoHealthCheckOnRelease(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Releases the channel back to the pool only if the channel is healthy.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> to put back to the pool.</param>
            <returns>
            <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was healthy, released, and offered back to the pool.
            <c>false</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was NOT healthy and was simply released.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryPollChannel(DotNetty.Transport.Channels.IChannel@)">
            <summary>
            Polls an <see cref="T:DotNetty.Transport.Channels.IChannel"/> out of the internal storage to reuse it.
            </summary>
            <remarks>
            Sub-classes may override <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryPollChannel(DotNetty.Transport.Channels.IChannel@)"/> and <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryOfferChannel(DotNetty.Transport.Channels.IChannel)"/>.
            Be aware that implementations of these methods needs to be thread-safe!
            </remarks>
            <param name="channel">
            An output parameter that will contain the <see cref="T:DotNetty.Transport.Channels.IChannel"/> obtained from the pool.
            </param>
            <returns>
            <c>true</c> if an <see cref="T:DotNetty.Transport.Channels.IChannel"/> was retrieved from the pool, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryOfferChannel(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Offers a <see cref="T:DotNetty.Transport.Channels.IChannel"/> back to the internal storage. This will return 
            </summary>
            <remarks>
            Sub-classes may override <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryPollChannel(DotNetty.Transport.Channels.IChannel@)"/> and <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryOfferChannel(DotNetty.Transport.Channels.IChannel)"/>.
            Be aware that implementations of these methods needs to be thread-safe!
            </remarks>
            <param name="channel"></param>
            <returns><c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> could be added, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.CloseAsync">
            <summary>
            Closes the pool in an async manner.
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> which represents completion of the close task</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.SingleThreadEventLoop">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> implementation based on <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(System.String)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup,System.String)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup,System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(System.String,System.TimeSpan,DotNetty.Common.Internal.IQueue{DotNetty.Common.Concurrency.IRunnable})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup,System.String,System.TimeSpan,DotNetty.Common.Internal.IQueue{DotNetty.Common.Concurrency.IRunnable})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.RegisterAsync(DotNetty.Transport.Channels.IChannel)">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Transport.Channels.SingleThreadEventLoop.Parent">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel`2">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2"/> base class for <see cref="T:DotNetty.Transport.Channels.IChannel"/>s that operate on bytes.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel`2.#ctor(DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>Create a new instance</summary>
            <param name="parent">the parent <see cref="T:DotNetty.Transport.Channels.IChannel"/> by which this instance was created. May be <c>null</c></param>
            <param name="socket">the underlying <see cref="T:System.Net.Sockets.Socket"/> on which it operates</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel`2.DoReadBytes(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Reads bytes into the given <see cref="T:DotNetty.Buffers.IByteBuffer"/> and returns the number of bytes that were read.
            </summary>
            <param name="buf">The <see cref="T:DotNetty.Buffers.IByteBuffer"/> to read bytes into.</param>
            <returns>The number of bytes that were read into the buffer.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel`2.DoWriteBytes(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Writes bytes from the given <see cref="T:DotNetty.Buffers.IByteBuffer"/> to the underlying <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="buf">The <see cref="T:DotNetty.Buffers.IByteBuffer"/> from which the bytes should be written.</param>
            <returns>The number of bytes that were written from the buffer.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2.ClearReadPending">
            <summary>
                Set read pending to <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2.ResetState(System.Int32)">
            <returns>state before modification</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2.OnIoCompleted(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <remarks>PORT NOTE: matches behavior of NioEventLoop.processSelectedKey</remarks>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2.DoConnect(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
                Connect to the remote peer
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2.DoFinishConnect(DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation{`0,`1})">
            <summary>
                Finish the connect
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2.ISocketChannelUnsafe.FinishConnect(DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation{`0,`1})">
            <summary>
                Finish connect
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2.ISocketChannelUnsafe.FinishRead(DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation{`0,`1})">
            <summary>
                Read from underlying {@link SelectableChannel}
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel`2">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel`2"/> base class for <see cref="T:DotNetty.Transport.Channels.IChannel"/>s that operate on messages.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel`2.#ctor(DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel`2"/> instance.
            </summary>
            <param name="parent">The parent <see cref="T:DotNetty.Transport.Channels.IChannel"/>. Pass <c>null</c> if there's no parent.</param>
            <param name="socket">The <see cref="T:System.Net.Sockets.Socket"/> used by the <see cref="T:DotNetty.Transport.Channels.IChannel"/> for communication.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel`2.ContinueOnWriteError">
            <summary>
            Returns <c>true</c> if we should continue the write loop on a write error.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel`2.DoReadMessages(System.Collections.Generic.List{System.Object})">
            <summary>
            Reads messages into the given list and returns the amount which was read.
            </summary>
            <param name="buf">The list into which message objects should be inserted.</param>
            <returns>The number of messages which were read.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel`2.DoWriteMessage(System.Object,DotNetty.Transport.Channels.ChannelOutboundBuffer)">
            <summary>
            Writes a message to the underlying <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="msg">The message to be written.</param>
            <param name="input">The destination channel buffer for the message.</param>
            <returns><c>true</c> if the message was successfully written, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent">
            <summary>
            Special event which will be fired and passed to the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/>
            methods once the input of an <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel"/> was shutdown and the
            <see cref="P:DotNetty.Transport.Channels.Sockets.ISocketChannelConfiguration.AllowHalfClosure"/> property returns <c>true</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent.Instance">
            <summary>
            Singleton instance to use.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.ChannelInputShutdownReadComplete">
            <summary>
            User event that signifies the channel's input side is shutdown, and we tried to shut it down again. This typically
            indicates that there is no more data to read.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Sockets.ChannelInputShutdownReadComplete.Instance">
            <summary>Singleton instance to use.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.ChannelOutputShutdownEvent">
            <summary>
            Special event which will be fired and passed to the
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> methods once the output of
            a <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel"/> was shutdown.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Sockets.ChannelOutputShutdownEvent.Instance">
            <summary>Singleton instance to use.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.DefaultServerSocketChannelConfig">
            <summary>
            The default <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannelConfiguration"/> implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.DefaultServerSocketChannelConfig.#ctor(DotNetty.Transport.Channels.Sockets.IServerSocketChannel,System.Net.Sockets.Socket)">
            <summary>
                Creates a new instance.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.DefaultSocketChannelConfiguration">
            <summary>
            The default <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannelConfiguration"/> implementation.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel">
            <summary>
            A TCP/IP <see cref="T:DotNetty.Transport.Channels.IServerChannel"/> which accepts incoming TCP/IP connections.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.SocketEx.EnableFastpath(System.Net.Sockets.Socket)">
            <summary>Enables TCP Loopback Fast Path on a socket.
            See https://blogs.technet.microsoft.com/wincat/2012/12/05/fast-tcp-loopback-performance-and-low-latency-with-windows-server-2012-tcp-loopback-fast-path/
            for more information.</summary>
            <param name="socket">The socket for which FastPath should be enabled.</param>
            <remarks>Code take from Orleans(See https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Messaging/SocketExtensions.cs). </remarks>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel`2">
            <summary>
                A <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel" /> implementation which uses Socket-based implementation to accept new
                connections.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel`2.#ctor">
            <summary>
                Create a new instance
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel`2.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>
                Create a new instance
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel`2.#ctor(System.Net.Sockets.Socket)">
            <summary>
                Create a new instance using the given <see cref="T:System.Net.Sockets.Socket"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>Create a new instance</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>Create a new instance using the given <see cref="T:System.Net.Sockets.Socket"/>.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.TcpSocketChannel`1">
            <summary>
                <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" /> which uses Socket-based implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel`1.#ctor">
            <summary>Create a new instance</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel`1.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>Create a new instance</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel`1.#ctor(System.Net.Sockets.Socket)">
            <summary>Create a new instance using the given <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" />.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel`1.#ctor(DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>Create a new instance</summary>
            <param name="parent">
                the <see cref="T:DotNetty.Transport.Channels.IChannel" /> which created this instance or <c>null</c> if it was created by the
                user
            </param>
            <param name="socket">the <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" /> which will be used</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor">
            <summary>Create a new instance</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>Create a new instance</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>Create a new instance using the given <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" />.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>Create a new instance</summary>
            <param name="parent">
                the <see cref="T:DotNetty.Transport.Channels.IChannel" /> which created this instance or <c>null</c> if it was created by the
                user
            </param>
            <param name="socket">the <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" /> which will be used</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.TaskExtensions.IsFault(System.Threading.Tasks.Task)">
            <summary>TBD</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Util.SafeSetSuccess(DotNetty.Common.Concurrency.IPromise,DotNetty.Common.Internal.Logging.IInternalLogger)">
            <summary>
            Marks the specified <see cref="T:DotNetty.Common.Concurrency.IPromise"/> as success. If the
            <see cref="T:DotNetty.Common.Concurrency.IPromise"/> is done already, logs a message.
            </summary>
            <param name="promise">The <see cref="T:DotNetty.Common.Concurrency.IPromise"/> to complete.</param>
            <param name="logger">The <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/> to use to log a failure message.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Util.SafeSetFailure(DotNetty.Common.Concurrency.IPromise,System.Exception,DotNetty.Common.Internal.Logging.IInternalLogger)">
            <summary>
            Marks the specified <see cref="T:DotNetty.Common.Concurrency.IPromise"/> as failure. If the
            <see cref="T:DotNetty.Common.Concurrency.IPromise"/> is done already, log a message.
            </summary>
            <param name="promise">The <see cref="T:DotNetty.Common.Concurrency.IPromise"/> to complete.</param>
            <param name="cause">The <see cref="T:System.Exception"/> to fail the <see cref="T:DotNetty.Common.Concurrency.IPromise"/> with.</param>
            <param name="logger">The <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/> to use to log a failure message.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.VoidChannelPromise.#ctor(DotNetty.Transport.Channels.IChannel,System.Boolean)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="channel">channel the <see cref="T:DotNetty.Transport.Channels.IChannel"/> associated with this future</param>
            <param name="fireException"></param>
        </member>
        <member name="T:DotNetty.Transport.Internal.Strings">
            <summary>
              
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Internal.Strings.ResourceManager">
            <summary>
               ResourceManager 
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Internal.Strings.Culture">
            <summary>
              
               CurrentUICulture 
            </summary>
        </member>
        <member name="T:DotNetty.Transport.ExceptionArgument">
            <summary>The convention for this enum is using the argument name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Transport.ExceptionResource">
            <summary>The convention for this enum is using the resource name as the enum name</summary>
        </member>
    </members>
</doc>
